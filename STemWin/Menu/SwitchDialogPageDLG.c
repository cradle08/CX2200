/*********************************************************************
*                                                                    *
*                SEGGER Microcontroller GmbH & Co. KG                *
*        Solutions for real time microcontroller applications        *
*                                                                    *
**********************************************************************
*                                                                    *
* C-file generated by:                                               *
*                                                                    *
*        GUI_Builder for emWin version 5.44                          *
*        Compiled Nov 10 2017, 08:53:57                              *
*        (c) 2017 Segger Microcontroller GmbH & Co. KG               *
*                                                                    *
**********************************************************************
*                                                                    *
*        Internet: www.segger.com  Support: support@segger.com       *
*                                                                    *
**********************************************************************
*/

// USER START (Optionally insert additional includes)
// USER END 

#include "DIALOG.h"
#include "Public_menuDLG.h"
#include "bsp_eeprom.h"
#include "file_operate.h"
#include "parameter.h"
#include "Common.h"
/*********************************************************************
*
*       Defines
*
**********************************************************************
*/
#define ID_WINDOW_0 (SWITCH_DIALOG_PAGE_ID + 0x00)
//#define ID_IMAGE_0 (SWITCH_DIALOG_PAGE_ID + 0x01)
#define ID_TEXT_IMAGE_0 (SWITCH_DIALOG_PAGE_ID + 0x01)
#define ID_TEXT_0 (SWITCH_DIALOG_PAGE_ID + 0x02)
#define ID_BUTTON_0 (SWITCH_DIALOG_PAGE_ID + 0x03)
#define ID_BUTTON_1 (SWITCH_DIALOG_PAGE_ID + 0x04)

// USER START (Optionally insert additional defines)
// USER END
/*********************************************************************
*
*       Static data
*
**********************************************************************
*/

//
static CommonSwitchDialogPageData_s SwitchDialogData = {0};


/*********************************************************************
*
*       _aDialogCreate
*/
static const GUI_WIDGET_CREATE_INFO _aDialogCreate[] = {
  { WINDOW_CreateIndirect, "SwitchDialogPage", ID_WINDOW_0, 180, 96, 440, 230, 0, 0x0, 0 },
  //{ IMAGE_CreateIndirect, "Image", ID_IMAGE_0, 173, 27, 90, 90, 0, 0, 0 },
  { TEXT_CreateIndirect, "Image", ID_TEXT_IMAGE_0, 173, 27, 90, 90, 0, 0, 0 },
  { TEXT_CreateIndirect, "Text", ID_TEXT_0, 50, 110, 340, 60, 0, 0x0, 0 },
  { BUTTON_CreateIndirect, "cel_b", ID_BUTTON_0, 0, 190, 220, 40, 0, 0x0, 0 },
  { BUTTON_CreateIndirect, "confim_b", ID_BUTTON_1, 220, 190, 220, 40, 0, 0x0, 0 },
  // USER START (Optionally insert additional widgets)
  // USER END
};

/*********************************************************************
*
*       Static code
*
**********************************************************************
*/

// image text callback
static void _Text_Image_Callback(WM_MESSAGE* pMsg, DialogBmpType_e eBmpType)
{
    switch(pMsg->MsgId)
    {
        case WM_PAINT:
        {
            GUI_RECT Rect;
            GUI_GetClientRect(&Rect);
            GUI_SetColor(GUI_WHITE);
            GUI_FillRectEx(&Rect);
            
            switch(eBmpType){
				case BMP_ALARM:
					Show_BK_BMP(BK_SDRAM, BK_PICTURE_SERVICE_Err, 0, 0);
				break;
				
				case BMP_OK:
					Show_BK_BMP(BK_SDRAM, BK_PICTURE_SERVICE_Ok, 0, 0);
				break;		
				case BMP_SELF_CHECK:
					Show_BK_BMP(BK_SDRAM, BK_PICTURE_SERVICE_SelfCheck, 0, 0);
				break;
				
				default :break;
			
            }
        }
        break;
        default:
            TEXT_Callback(pMsg);
            break;
    }

}

//iamge 
static void Text_Image_Callback(WM_MESSAGE* pMsg)
{
    _Text_Image_Callback(pMsg, SwitchDialogData.dialogData.bmpType);
}


// USER START (Optionally insert additional static code)
static void _SwitchDialogPageRedrawWidgetType_Callback(WM_MESSAGE* pMsg)
{
    switch (pMsg->MsgId)
    {
    case WM_PAINT:
    {
        GUI_RECT Rect;
        WM_GetClientRect(&Rect);

        if (BUTTON_IsPressed(pMsg->hWin)) {
			//填充
			GUI_SetColor(MachInfo.companyInfo.skin.highlightKJSelect);
			GUI_FillRectEx(&Rect);
			
			//设置字符前景和背景色
			GUI_SetColor(MachInfo.companyInfo.skin.highlightKJSelectFont);
			GUI_SetBkColor(MachInfo.companyInfo.skin.highlightKJSelect);
			
			switch(WM_GetId(pMsg->hWin)){
				//取消按钮
				case ID_BUTTON_0:
					GUI_DispStringInRect(g_ucaLng_Cancel[MachInfo.systemSet.eLanguage],&Rect,GUI_TA_HCENTER|GUI_TA_VCENTER);
				break;
				
				//确认按钮
				case ID_BUTTON_1:
					GUI_DispStringInRect(g_ucaLng_Sure[MachInfo.systemSet.eLanguage],&Rect,GUI_TA_HCENTER|GUI_TA_VCENTER);
				break;
				
				default :break;
			}
        }
        else{
			switch(WM_GetId(pMsg->hWin)){
				//取消按钮
				case ID_BUTTON_0:
					GUI_SetColor(GUI_LIGHTGRAY);
					GUI_FillRect(Rect.x0, Rect.y0, Rect.x1, Rect.y1);
					GUI_SetColor(BTN_CHAR_COLOR);
					GUI_SetBkColor(GUI_LIGHTGRAY);
				
					GUI_DispStringInRect(g_ucaLng_Cancel[MachInfo.systemSet.eLanguage],&Rect,GUI_TA_HCENTER|GUI_TA_VCENTER);
				break;
				
				//确认按钮
				case ID_BUTTON_1:
					GUI_SetColor(MachInfo.companyInfo.skin.highlightKJNotSelect);
					GUI_FillRect(Rect.x0, Rect.y0, Rect.x1, Rect.y1);
					GUI_SetColor(MachInfo.companyInfo.skin.highlightKHNotSelectFont);
					GUI_SetBkColor(MachInfo.companyInfo.skin.highlightKJNotSelect);
				
					GUI_DispStringInRect(g_ucaLng_Sure[MachInfo.systemSet.eLanguage],&Rect,GUI_TA_HCENTER|GUI_TA_VCENTER);
				break;
				
				default :break;
			}
        }
    }
    break;
    default:
        BUTTON_Callback(pMsg);
        break;
    }
}



static void _SwitchDialogPageRedrawWidgetType(WM_MESSAGE* pMsg)
{
    WM_HWIN hItem;
	
	//取消按钮
    hItem = WM_GetDialogItem(pMsg->hWin, ID_BUTTON_0);  
    WM_SetCallback(hItem, _SwitchDialogPageRedrawWidgetType_Callback);
    WM_InvalidateWindow(hItem);
	
    //确定按钮
    hItem = WM_GetDialogItem(pMsg->hWin, ID_BUTTON_1);  
    WM_SetCallback(hItem, _SwitchDialogPageRedrawWidgetType_Callback);
    WM_InvalidateWindow(hItem);
}
// USER END

/*********************************************************************
*
*       _cbDialog
*/
static void _cbDialog(WM_MESSAGE * pMsg) {
  WM_HWIN      hItem;
  int          NCode;
  int          Id;
  // USER START (Optionally insert additional variables)
	extern  MachInfo_s	MachInfo;
	extern  __IO MachRunPara_s       MachRunPara;
	extern osMessageQueueId_t CATQueueHandle;
	extern WM_HWIN CreateDialogPage(void);
	
	//static CommonSwitchDialogPageData_s SwitchDialogData = {0};
	
	GUI_RECT Rect;
    WM_GetClientRect(&Rect);
	
	char StrTemp[100] = {0};
	uint16_t U16Temp1 = 0;
	CATQueueInfoBuf_s CATQueueInfoBuf = {0};
	
	Msg_Head_t BackendMsg = {0};
	CommonDialogPageData_s DialogPageData = {0};
  // USER END

  switch (pMsg->MsgId) {
  case WM_INIT_DIALOG:
    //
    // Initialization of 'Image'
    //
    hItem = WM_GetDialogItem(pMsg->hWin, ID_TEXT_IMAGE_0);
	//IMAGE_SetBMP(hItem, ErrBmpDataBuf, ErrBmpBufLen);
    WM_SetCallback(hItem, Text_Image_Callback);
    //
    // Initialization of 'Text'
    //
    hItem = WM_GetDialogItem(pMsg->hWin, ID_TEXT_0);
    TEXT_SetTextAlign(hItem, GUI_TA_HCENTER | GUI_TA_VCENTER);
  
	//重绘按钮样式
	_SwitchDialogPageRedrawWidgetType(pMsg);
    // USER START (Optionally insert additional code for further widget initialization)
    // USER END
    break;
  
  case WM_PAINT:
	//先设置弹窗和背景为相同的透明度
	GUI_SetColor(0x00525a4e);
	GUI_FillRectEx(&Rect);
  
	//重绘弹窗为圆角矩形
	GUI_SetColor(0x00ffffff);
	GUI_AA_FillRoundedRectEx(&Rect,6);
  break;
  
  //用户数据
  case WM_USER_DATA:
		SwitchDialogData = *((CommonSwitchDialogPageData_s*)pMsg->Data.p);
  
        hItem = WM_GetDialogItem(pMsg->hWin,ID_TEXT_0);
        if(LISTVIEW_DELETE_DATA == SwitchDialogData.switchDialogItem)
        {
            TEXT_SetFont(hItem, &HZ_SONGTI_16);
        }
        TEXT_SetText(hItem,SwitchDialogData.dialogData.str);
  
		//选择显示的图标
		hItem = WM_GetDialogItem(pMsg->hWin, ID_TEXT_IMAGE_0);
        WM_InvalidateWindow(hItem);
//		switch(SwitchDialogData.dialogData.bmpType){
//			case BMP_ALARM:
//				IMAGE_SetBMP(hItem, ErrBmpDataBuf, ErrBmpBufLen);
//			break;
//			
//			case BMP_OK:
//				IMAGE_SetBMP(hItem, SuccessBmpDataBuf, SuccessBmpBufLen);
//			break;
//			
//			case BMP_SELF_CHECK:
//				IMAGE_SetBMP(hItem, SelfCheckBmpDataBuf, SelfCheckBmpBufLen);
//			break;
//			
//			default :break;
//		}
  break;
  
  case WM_NOTIFY_PARENT:
    Id    = WM_GetId(pMsg->hWinSrc);
    NCode = pMsg->Data.v;
    switch(Id) {
    case ID_BUTTON_0: // Notifications sent by 'cel_b'
      switch(NCode) {
      case WM_NOTIFICATION_CLICKED:
        // USER START (Optionally insert code for reacting on notification message)
        // USER END
        break;
      case WM_NOTIFICATION_RELEASED:
        // USER START (Optionally insert code for reacting on notification message)
		GUI_EndDialog(pMsg->hWin, 0);
		g_hActiveWin = SwitchDialogData.dialogData.fun();
        // USER END
        break;
      // USER START (Optionally insert additional code for further notification handling)
      // USER END
      }
      break;
    case ID_BUTTON_1: // Notifications sent by 'confim_b'
      switch(NCode) {
      case WM_NOTIFICATION_CLICKED:
        // USER START (Optionally insert code for reacting on notification message)
        // USER END
        break;
      case WM_NOTIFICATION_RELEASED:
        // USER START (Optionally insert code for reacting on notification message)
		switch(SwitchDialogData.switchDialogItem){
			//===登录界面===
			//登录界面恢复出厂设置按钮
			case LOGIN_RESET_MACHINE_PARA:
			{
				MachInfo.initFlag = 0;
				EEPROMWriteData(EEPROM_24C32,MAIN_BORD_EEPROM_24C32,EPPROM_ADDR_MACHINFO_INIT_FLAG,(uint8_t*)&MachInfo.initFlag,sizeof(MachInfo.initFlag));
			
				osDelay(500);
				
				//重新登录
				__set_PRIMASK(1);
				NVIC_SystemReset();
			}
			break;
			
			//===设置===
			//恢复出厂密码
			case CONFIG_USERMANAGE_RECOVER_FACTORY_PSW:
			{
				//运行日志缓存区
				RunLog_s RunLog = {0};
				RTC_HYM8563Info_s RTCInfo = {0};
				uint32_t ulIndex = 0;
				//保存运行日志
				RunLog.logHead.num = g_tDataManage.ulRunLog_SN;//g_tDataManage.lastRunLogNum;
				RunLog.logHead.eAccountType = MachInfo.accountMM.accountInfo[MachInfo.accountMM.curIndex].type;
				RTC_HYM8563GetTime(&RTCInfo);
				sprintf(RunLog.logHead.dataTime,"20%d%d-%d%d-%d%d %d%d:%d%d:%d%d",
								RTCInfo.year.bcd_h,RTCInfo.year.bcd_l,
								RTCInfo.month.bcd_h,RTCInfo.month.bcd_l,
								RTCInfo.day.bcd_h,RTCInfo.day.bcd_l,
								RTCInfo.hour.bcd_h,RTCInfo.hour.bcd_l,
								RTCInfo.min.bcd_h,RTCInfo.min.bcd_l,
								RTCInfo.sec.bcd_h,RTCInfo.sec.bcd_l);
				sprintf(RunLog.logHead.shortStr,"Reset Factory PSW");
				RunLog.logHead.timestamp = GetCurrentTimestamp(RTCInfo);
				
				//根据传递进来的账户索引值来判断执行重置操作
				switch(MachInfo.accountMM.accountInfo[SwitchDialogData.u32].type){
					//工程师账号
					case ACCOUNT_TYPE_SUPER:
						strcpy(MachInfo.accountMM.accountInfo[ACCOUNT_TYPE_SUPER].psw,ACCOUNT_SUPER_DEFAULT_PSW);
						RunLog.logHead.logLen += sprintf(RunLog.Str+RunLog.logHead.logLen,"Restore the factory password of user super");
					break;
					
					//管理员
					case ACCOUNT_TYPE_ADMIN:
						strcpy(MachInfo.accountMM.accountInfo[ACCOUNT_TYPE_ADMIN].psw,ACCOUNT_ADMIN_DEFAULT_PSW);
						RunLog.logHead.logLen += sprintf(RunLog.Str+RunLog.logHead.logLen,"Restore the factory password of user admin");
					break;
					
					//普通用户
					case ACCOUNT_TYPE_NORMAL:
						strcpy(MachInfo.accountMM.accountInfo[ACCOUNT_TYPE_NORMAL].psw,ACCOUNT_NORMAL_DEFAULT_PSW);
						RunLog.logHead.logLen += sprintf(RunLog.Str+RunLog.logHead.logLen,"Restore the factory password of user 001");
					break;
					
					//新增用户，密码重置为用户名一致
					case ACCOUNT_TYPE_NEW:
						strcpy(MachInfo.accountMM.accountInfo[SwitchDialogData.u32].psw,MachInfo.accountMM.accountInfo[SwitchDialogData.u32].user);
						RunLog.logHead.logLen += sprintf(RunLog.Str+RunLog.logHead.logLen,"Restore the factory password of user %s",MachInfo.accountMM.accountInfo[SwitchDialogData.u32].user);
					break;
					default :break;
				}
				
				//运行日志相关
				RunLog.Str[RunLog.logHead.logLen] = '\0';
                RunLog.usCrc = CRC16((uint8_t*)&RunLog, sizeof(RunLog_s)-2);
                ulIndex = Update_RunLog_Tail();
				Fatfs_Write_RunLog(ulIndex, &RunLog);
                
                Add_RunLog_Tail();
				g_tDataManage.ulRunLog_SN++;
				Save_DataMange_Info(&g_tDataManage);
				
				EEPROMWriteData(EEPROM_24C32,MAIN_BORD_EEPROM_24C32,EPPROM_ADDR_MACHINFO_ACCOUNT_MM,(uint8_t*)&MachInfo.accountMM,sizeof(MachInfo.accountMM));
			
				//标记CAT必发项
				if(MachInfo.catMastSynServEvent.bit.sendRunLog != 1){
					MachInfo.catMastSynServEvent.bit.sendRunLog = 1;
					EEPROMWriteData(EEPROM_24C32,MAIN_BORD_EEPROM_24C32,EPPROM_ADDR_MACHINFO_CAT_SYNC_SER_EVENT,(uint8_t*)&MachInfo.catMastSynServEvent,sizeof(MachInfo.catMastSynServEvent));
				}
				
				//返回调用界面
				GUI_EndDialog(pMsg->hWin, 0);
				g_hActiveWin = SwitchDialogData.dialogData.fun();
			}
			break;
			
			//删除用户
			case CONFIG_DEL_USER:
			{
				//运行日志缓存区
				RunLog_s RunLog = {0};
				RTC_HYM8563Info_s RTCInfo = {0};
				uint32_t ulIndex = 0;
				uint8_t i = 0;
				
				//保存运行日志
				RunLog.logHead.num = g_tDataManage.ulRunLog_SN;//g_tDataManage.lastRunLogNum;
				RunLog.logHead.eAccountType = MachInfo.accountMM.accountInfo[MachInfo.accountMM.curIndex].type;
				RTC_HYM8563GetTime(&RTCInfo);
				sprintf(RunLog.logHead.dataTime,"20%d%d-%d%d-%d%d %d%d:%d%d:%d%d",
								RTCInfo.year.bcd_h,RTCInfo.year.bcd_l,
								RTCInfo.month.bcd_h,RTCInfo.month.bcd_l,
								RTCInfo.day.bcd_h,RTCInfo.day.bcd_l,
								RTCInfo.hour.bcd_h,RTCInfo.hour.bcd_l,
								RTCInfo.min.bcd_h,RTCInfo.min.bcd_l,
								RTCInfo.sec.bcd_h,RTCInfo.sec.bcd_l);
				sprintf(RunLog.logHead.shortStr,"Del User");
				RunLog.logHead.timestamp = GetCurrentTimestamp(RTCInfo);
				RunLog.logHead.logLen += sprintf(RunLog.Str+RunLog.logHead.logLen,"Del User:%s",MachInfo.accountMM.accountInfo[SwitchDialogData.u32].user);
				
				//判断要删除的账户是否是默认账户，是，则将默认用户重新赋值
				if(MachInfo.accountMM.defaultIndex == SwitchDialogData.u32){
					//指定到普通用户上去
					MachInfo.accountMM.defaultIndex = ACCOUNT_TYPE_NORMAL;
				}else if(MachInfo.accountMM.defaultIndex > SwitchDialogData.u32){
					//默认用户在删除用户后面，则需要将默认用户索引前移
					MachInfo.accountMM.defaultIndex--;
				}
				
				//根据传递进来的账户索引值来执行删除用户
				for(i=SwitchDialogData.u32;i<MachInfo.accountMM.endIndex-1;i++){
					MachInfo.accountMM.accountInfo[i] = MachInfo.accountMM.accountInfo[i+1];
				}
				
				MachInfo.accountMM.endIndex--;
				EEPROMWriteData(EEPROM_24C32,MAIN_BORD_EEPROM_24C32,EPPROM_ADDR_MACHINFO_ACCOUNT_MM,(uint8_t*)&MachInfo.accountMM,sizeof(MachInfo.accountMM));
				
				//运行日志相关
				RunLog.Str[RunLog.logHead.logLen] = '\0';
                RunLog.usCrc = CRC16((uint8_t*)&RunLog, sizeof(RunLog_s)-2);
                ulIndex = Update_RunLog_Tail();
				Fatfs_Write_RunLog(ulIndex, &RunLog);
                
                Add_RunLog_Tail();
				g_tDataManage.ulRunLog_SN++;
				Save_DataMange_Info(&g_tDataManage);
				
				//标记CAT必发项
				if(MachInfo.catMastSynServEvent.bit.sendRunLog != 1){
					MachInfo.catMastSynServEvent.bit.sendRunLog = 1;
					EEPROMWriteData(EEPROM_24C32,MAIN_BORD_EEPROM_24C32,EPPROM_ADDR_MACHINFO_CAT_SYNC_SER_EVENT,(uint8_t*)&MachInfo.catMastSynServEvent,sizeof(MachInfo.catMastSynServEvent));
				}
				
				//返回调用界面
				GUI_EndDialog(pMsg->hWin, 0);
				g_hActiveWin = SwitchDialogData.dialogData.fun();
			}
			break;
			
			//修改仪器序列号
			case CONFIG_LAB_INFO_CHANGE_SN:
			{
				extern osEventFlagsId_t GlobalEventCatGroupHandle;
				
				//先清除网络异常事件标志
				osEventFlagsClear(GlobalEventCatGroupHandle,GLOBAL_EVENT_CAT_CONN_NET_ERR);
				
				//这里需要向服务端发送指令
				CATQueueInfoBuf.msgType = CHANGE_MACHINE_INFO_CAT_MSG_TYPGE;
				CATQueueInfoBuf.para.changeMachineInfo.changeType = 0;					//0表示通知服务端修改了SN
				osMessageQueuePut(CATQueueHandle,&CATQueueInfoBuf,0,0);
				
				GUI_EndDialog(g_hActiveWin, 0);
				g_hActiveWin = CreateDialogPage();
			
				//保存对话框内容
				DialogPageData.bmpType = BMP_ALARM;
				DialogPageData.confimButt = NO_CONFIM_BUTTON;
				DialogPageData.fun = SwitchDialogData.dialogData.fun;
				strcpy(DialogPageData.str,g_ucaLng_SET_ChangeSning[MachInfo.systemSet.eLanguage]);
			
				//发送对话框消息
				pMsg->MsgId = WM_USER_DATA;
				pMsg->Data.p = &DialogPageData;
				WM_SendMessage(g_hActiveWin,pMsg);
			  
				//往后台发送消息
				BackendMsg.usCmd = CMD_CHANGE_SN_WAIT_CAT;
				UI_Put_Msg((uint8_t*)&BackendMsg);
			}break;
			
			//修改测试数据容量
			case CONFIG_CHANGE_DATA_NUM:
			{
				extern OutSideDataNum_s OutSideDataNum;
				
				OutSideDataNum.index = SwitchDialogData.u32;
				EEPROMWriteData(EEPROM_24C32,MAIN_BORD_EEPROM_24C32,EPPROM_ADDR_DATA_OUTSIDE_NUM,(uint8_t*)&OutSideDataNum,sizeof(OutSideDataNum_s));
				
				//重置数据管理结构体
				Set_Default_DataManage(&g_tDataManage);
				Save_DataMange_Info(&g_tDataManage);
				
				osDelay(500);
				
				//重新登录
				__set_PRIMASK(1);
				NVIC_SystemReset();
			}break;
			
			//U盘升级
			case CONFIG_U_UPDATE:
			{
				GUI_EndDialog(g_hActiveWin, 0);
				g_hActiveWin = CreateDialogPage();
			
				//保存对话框内容
				DialogPageData.bmpType = BMP_ALARM;
				DialogPageData.confimButt = NO_CONFIM_BUTTON;
				DialogPageData.fun = SwitchDialogData.dialogData.fun;
				strcpy(DialogPageData.str,g_ucaLng_START_UPDATE[MachInfo.systemSet.eLanguage]);
			
				//发送对话框消息
				pMsg->MsgId = WM_USER_DATA;
				pMsg->Data.p = &DialogPageData;
				WM_SendMessage(g_hActiveWin,pMsg);
			  
				//往后台发送消息
				BackendMsg.usCmd = CMD_SET_U_UPDATE;
				UI_Put_Msg((uint8_t*)&BackendMsg);
			}break;
				
			//===服务===
			//重置仪器参数
			case SERVICE_DATAMANAGE_RESET_PARA:
			{
				//运行日志缓存区
				RunLog_s RunLog = {0};
				RTC_HYM8563Info_s RTCInfo = {0};
				uint32_t ulIndex = 0;
				uint8_t CatConnFlag = 0;
				
				//保存运行日志
				RunLog.logHead.num = g_tDataManage.ulRunLog_SN;// g_tDataManage.lastRunLogNum;
				RunLog.logHead.eAccountType = MachInfo.accountMM.accountInfo[MachInfo.accountMM.curIndex].type;
				RTC_HYM8563GetTime(&RTCInfo);
				sprintf(RunLog.logHead.dataTime,"20%d%d-%d%d-%d%d %d%d:%d%d:%d%d",
								RTCInfo.year.bcd_h,RTCInfo.year.bcd_l,
								RTCInfo.month.bcd_h,RTCInfo.month.bcd_l,
								RTCInfo.day.bcd_h,RTCInfo.day.bcd_l,
								RTCInfo.hour.bcd_h,RTCInfo.hour.bcd_l,
								RTCInfo.min.bcd_h,RTCInfo.min.bcd_l,
								RTCInfo.sec.bcd_h,RTCInfo.sec.bcd_l);
				sprintf(RunLog.logHead.shortStr,"Reset Parameters");
				RunLog.logHead.logLen += sprintf(RunLog.Str+RunLog.logHead.logLen,"Reset instrument parameters");
				RunLog.Str[RunLog.logHead.logLen] = '\0';
                
				RunLog.logHead.timestamp = GetCurrentTimestamp(RTCInfo);
                RunLog.usCrc = CRC16((uint8_t*)&RunLog, sizeof(RunLog_s)-2);
                
                ulIndex = Update_RunLog_Tail();
				Fatfs_Write_RunLog(ulIndex, &RunLog);
                
				g_tDataManage.ulRunLog_SN++;//g_tDataManage.lastRunLogNum++;
                Add_RunLog_Tail();
				Save_DataMange_Info(&g_tDataManage);
				
				
				//先保存仪器一些不能被重置掉的参数信息
				memset(StrTemp,0,15);
				strcpy(StrTemp,(char*)MachInfo.labInfo.ucaMachineSN);
				U16Temp1 = MachInfo.accountMM.curIndex;
				CatConnFlag = MachInfo.flag.bit.connNet;
				
				//设置默认信息
				Machine_InitPara();
			
				//还原部分信息
				MachInfo.accountMM.curIndex = U16Temp1;
				strcpy((char*)MachInfo.labInfo.ucaMachineSN,StrTemp);
				MachInfo.flag.bit.connNet = CatConnFlag;
				
				//标记CAT必发事件标记
				MachInfo.catMastSynServEvent.bit.paraSet = 1;
				MachInfo.catMastSynServEvent.bit.sendRunLog = 1;
				
				//保存信息
				EEPROMWriteData(EEPROM_24C32,MAIN_BORD_EEPROM_24C32,EPPROM_ADDR_MACHINFO_ACCOUNT_MM,(uint8_t*)&MachInfo.accountMM,sizeof(MachInfo.accountMM));
				EEPROMWriteData(EEPROM_24C32,MAIN_BORD_EEPROM_24C32,EPPROM_ADDR_MACHINFO_LAB_INFO,(uint8_t*)&MachInfo.labInfo,sizeof(MachInfo.labInfo));
				EEPROMWriteData(EEPROM_24C32,MAIN_BORD_EEPROM_24C32,EPPROM_ADDR_MACHINFO_CAT_SYNC_SER_EVENT,(uint8_t*)&MachInfo.catMastSynServEvent,sizeof(MachInfo.catMastSynServEvent));
				EEPROMWriteData(EEPROM_24C32,MAIN_BORD_EEPROM_24C32,EPPROM_ADDR_MACHINFO_FLAG,(uint8_t*)&MachInfo.flag,sizeof(MachInfo.flag));
			
				osDelay(500);
				
				//重新登录
				__set_PRIMASK(1);
				NVIC_SystemReset();
			}
			break;
			
			//删除测试数据
			case SERVICE_DATAMANAGE_DEL_TEST_DATA:
				GUI_EndDialog(g_hActiveWin, 0);
				g_hActiveWin = CreateDialogPage();
			
				//保存对话框内容
				DialogPageData.bmpType = BMP_ALARM;
				DialogPageData.confimButt = NO_CONFIM_BUTTON;
				DialogPageData.fun = SwitchDialogData.dialogData.fun;
				strcpy(DialogPageData.str,g_ucaLng_SET_DelTestDataing[MachInfo.systemSet.eLanguage]);
			
				//发送对话框消息
				pMsg->MsgId = WM_USER_DATA;
				pMsg->Data.p = &DialogPageData;
				WM_SendMessage(g_hActiveWin,pMsg);
			  
				//往后台发送消息
				BackendMsg.usCmd = CMD_SERVER_DEL_TEST_DATA;
				UI_Put_Msg((uint8_t*)&BackendMsg);
			break;
			
			//删除用户数据
			case SERVICE_DATAMANAGE_DEL_USER_DATA:
				GUI_EndDialog(g_hActiveWin, 0);
				g_hActiveWin = CreateDialogPage();
			
				//保存对话框内容
				DialogPageData.bmpType = BMP_ALARM;
				DialogPageData.confimButt = NO_CONFIM_BUTTON;
				DialogPageData.fun = SwitchDialogData.dialogData.fun;
				strcpy(DialogPageData.str,g_ucaLng_SET_DelUserDataing[MachInfo.systemSet.eLanguage]);
			
				//发送对话框消息
				pMsg->MsgId = WM_USER_DATA;
				pMsg->Data.p = &DialogPageData;
				WM_SendMessage(g_hActiveWin,pMsg);
			  
				//往后台发送消息
				BackendMsg.usCmd = CMD_SERVER_DEL_USER_DATA;
				UI_Put_Msg((uint8_t*)&BackendMsg);
			break;
			
			//恢复出厂设置
			case SERVICE_DATAMANAGE_RECOVER_FACTORY:
			{
				GUI_EndDialog(g_hActiveWin, 0);
				g_hActiveWin = CreateDialogPage();
			
				//保存对话框内容
				DialogPageData.bmpType = BMP_ALARM;
				DialogPageData.confimButt = NO_CONFIM_BUTTON;
				DialogPageData.fun = SwitchDialogData.dialogData.fun;
				strcpy(DialogPageData.str,g_ucaLng_SET_RecoverFactory[MachInfo.systemSet.eLanguage]);
			
				//发送对话框消息
				pMsg->MsgId = WM_USER_DATA;
				pMsg->Data.p = &DialogPageData;
				WM_SendMessage(g_hActiveWin,pMsg);
				
        		//往后台发送消息
				BackendMsg.usCmd = CMD_SERVER_RECOVER_FACTORY;
				UI_Put_Msg((uint8_t*)&BackendMsg);
			}
			break;
            case LISTVIEW_DELETE_DATA:  //列表回顾，结果详情删除数据
            {
                ListReview_t tListView = {0};
                tListView.tMsgHead.usCmd        = CMD_LIST_REVIEW_DELETE;
                tListView.tMsgHead.eErrorCode   = ERROR_CODE_SUCCESS; 
                tListView.tMsgHead.usMsgLen     = MSG_HEAD_LEN; 
                tListView.ucIndex               = g_ucListView_DataIndex;               
                //发送消息
                UI_Put_Msg((uint8_t*)&tListView);
                
                //返回列表回顾界面
                GUI_EndDialog(pMsg->hWin, 0);
                g_hActiveWin = CreateListReview_Window();
  
            }
            break;
			
			//关机
            case MENU_POWER_OFF_PROMPT:
            {
                //
                if(ConutCell_Is_Exist() == SET) //存在计数池
                {
					Msg_Head_t tMsgHead = {0};
					
					//更新提示字符即可
					hItem = WM_GetDialogItem(pMsg->hWin,ID_TEXT_0);
					TEXT_SetText(hItem,g_ucaLng_TakeOutCell_Before_PowerOff[MachInfo.systemSet.eLanguage]);
					GUI_Exec();
					
					//出仓
					tMsgHead.usCmd = CMD_OTHERS_OUTIN_OUT;
					UI_Put_Msg((uint8_t*)&tMsgHead);
                }else{
					//切换到关机画面
					GUI_EndDialog(pMsg->hWin, 0);  
                    g_hActiveWin = PowerOff_CreateWindow(); 
					
                    //发送关机消息给后端，执行关机操作
                    Msg_Head_t tMsgHead = {0};
                    //构造关机消息
                    tMsgHead.usCmd      = CMD_POWEROFF_EXEC;
                    tMsgHead.eErrorCode = ERROR_CODE_SUCCESS;
                    tMsgHead.usMsgLen   = MSG_HEAD_LEN;
                    //发送消息给后端
                    UI_Put_Msg((uint8_t*)&tMsgHead); 
                }
            }
            break;	
            case MENU_POWER_OFF_TAKEOUT_CELL:
            {
                GUI_EndDialog(pMsg->hWin, 0);
                g_hActiveWin = Createmenu_Window();
            }
            break;
            case MENU_LOGOUT_PROMPT:
            { 
                //注销
                GUI_EndDialog(pMsg->hWin, 0);
                g_hActiveWin = CreateLogin_Window();
            }
            break;	
			
			//开启下拉患者信息功能，且网络异常，是否进入手动录入患者信息界面
			case ANALYSE_NET_ERR_MUNAUL_INPUT_INFO:
            { 
				extern WM_HWIN CreateNextSample_Window(void);
				
								
                GUI_EndDialog(pMsg->hWin, 0);
                g_hActiveWin = CreateNextSample_Window();
            }
            break;
			default :break;
		}
		
		
        // USER END
        break;
      // USER START (Optionally insert additional code for further notification handling)
      // USER END
      }
      break;
    // USER START (Optionally insert additional code for further Ids)
    // USER END
    }
    break;
  // USER START (Optionally insert additional message handling)
  // USER END
  default:
    WM_DefaultProc(pMsg);
    break;
  }
}

/*********************************************************************
*
*       Public code
*
**********************************************************************
*/
/*********************************************************************
*
*       CreateSwitchDialogPage
*/
WM_HWIN CreateSwitchDialogPage(void);
WM_HWIN CreateSwitchDialogPage(void) {
  WM_HWIN hWin;
	
	WM_SetCallback(WM_HBKWIN, AlphaBk_cbBkWin);
	Public_Hide_Widget();
	
  hWin = GUI_CreateDialogBox(_aDialogCreate, GUI_COUNTOF(_aDialogCreate), _cbDialog, WM_HBKWIN, 0, 0);
  return hWin;
}

// USER START (Optionally insert additional public code)
// USER END

/*************************** End of file ****************************/
