/*********************************************************************
*                                                                    *
*                SEGGER Microcontroller GmbH & Co. KG                *
*        Solutions for real time microcontroller applications        *
*                                                                    *
**********************************************************************
*                                                                    *
* C-file generated by:                                               *
*                                                                    *
*        GUI_Builder for emWin version 5.44                          *
*        Compiled Nov 10 2017, 08:53:57                              *
*        (c) 2017 Segger Microcontroller GmbH & Co. KG               *
*                                                                    *
**********************************************************************
*                                                                    *
*        Internet: www.segger.com  Support: support@segger.com       *
*                                                                    *
**********************************************************************
*/

// USER START (Optionally insert additional includes)
// USER END

#include "DIALOG.h"
#include "WM.h"
#include "GUI.h"
#include "LISTBOX.h"

#include "Analysis_MenuDLG.h"
#include "Public_menuDLG.h"
/*********************************************************************
*
*       Defines
*
**********************************************************************
*/



//ID
#define ID_WINDOW_PORMPT      (ID_WINDOW_ERROR_PROMPT + 0x00)
#define ID_ERROR_PROMPT_TEXT        (ID_WINDOW_ERROR_PROMPT + 0x01)
#define ID_ERROR_PROMPT_BUTTON      (ID_WINDOW_ERROR_PROMPT + 0x02)





// USER START (Optionally insert additional defines)
// USER END

/*********************************************************************
*
*       Static data
*
**********************************************************************
*/



// USER START (Optionally insert additional static data)
// USER END

/*********************************************************************
*
*       _aDialogCreate
*/

static const GUI_WIDGET_CREATE_INFO ErrorPrompt_aDialogCreate[] = {
  { WINDOW_CreateIndirect, "Error_Prompt", ID_WINDOW_ERROR_PORMPT,    140, 95, 520, 280, 0, 0x0, 0 },
  { TEXT_CreateIndirect,   "",       	   ID_ERROR_PROMPT_TEXT,      110, 160, 300, 40, 0, 0x0, 0 },
  { BUTTON_CreateIndirect, "确定",         ID_ERROR_PROMPT_BUTTON,   0, 240, 520, 40, 0, 0x0, 0 },

  
  //{ LISTWHEEL_CreateIndirect,   "Month_Listwheel",      ID_LISTWHEEL_MONTH,         170, 150, 45, 30, 0, 0x0, 0 },
  //{ LISTWHEEL_CreateIndirect,   "Day_Listwheel",        ID_LISTWHEEL_DAY,           215, 150, 45, 30, 0, 0x0, 0 },
  // USER START (Optionally insert additional widgets)
  // USER END
};





/*********************************************************************
*
*       Static code
*
**********************************************************************
*/


/*
*  ErrorPrompt  btn callback
*/
static void Prompt_Btn_Callback(WM_MESSAGE* pMsg)
{
    const unsigned char RoundRadius = 0; //显示区域圆角半径
    switch (pMsg->MsgId)
    {
    case WM_PAINT:
    {
        GUI_RECT Rect;
        WM_GetClientRect(&Rect);

        if (BUTTON_IsPressed(pMsg->hWin)) {
            //draw frame
            GUI_SetColor(GUI_BTN_PRESS_COLOR);
            GUI_AA_FillRoundedRect(Rect.x0, Rect.y0, Rect.x1, Rect.y1, RoundRadius);
            GUI_SetColor(GUI_BTN_FRAME_COLOR);
            //GUI_AA_DrawRoundedRect(Rect.x0 + 1, Rect.y0 + 1, Rect.x1 + 1, Rect.y1 + 1, RoundRadius);
            GUI_DrawRect(Rect.x0, Rect.y0, Rect.x1, Rect.y1);;

            // display char
            GUI_SetColor(GUI_BTN_PRESS_CHAR_COLOR);
            GUI_SetBkColor(GUI_BTN_PRESS_COLOR);
            if(ID_ERROR_PROMPT_BUTTON == WM_GetId(pMsg->hWin))
            {
                GUI_DispStringInRect("确定", &Rect, GUI_TA_HCENTER | GUI_TA_VCENTER);
            }   
        }
        else {
            // draw frame
            GUI_SetColor(GUI_BTN_RELEASE_COLOR);
            GUI_AA_FillRoundedRect(Rect.x0, Rect.y0, Rect.x1, Rect.y1, RoundRadius);
            GUI_SetColor(GUI_BTN_FRAME_COLOR);
            //GUI_AA_DrawRoundedRect(Rect.x0 + 1, Rect.y0 + 1, Rect.x1, Rect.y1, RoundRadius);
            GUI_DrawRect(Rect.x0, Rect.y0, Rect.x1, Rect.y1);;

            // display char
            GUI_SetColor(GUI_BTN_RELEASE_CHAR_COLOR);
            GUI_SetBkColor(GUI_BTN_RELEASE_COLOR);
            if (ID_ERROR_PROMPT_BUTTON == WM_GetId(pMsg->hWin))
            {
                GUI_DispStringInRect("确定", &Rect, GUI_TA_HCENTER | GUI_TA_VCENTER);
            }
  
        }
    }
    break;
    default:
        BUTTON_Callback(pMsg);
        break;
    }
}






/*********************************************************************
*
*       _cbDialog
*/
static void ErrorPrompt_cbDialog(WM_MESSAGE* pMsg) {
    
    extern __IO uint32_t g_ulErrorCode;
    WM_HWIN hItem;
    int     NCode;
    int     Id;
    char buffer[50] = {0};


    switch (pMsg->MsgId) {
    case WM_INIT_DIALOG:
        //
        // Initialization of 'Remark_Multiedit'
        //...
		
		//btn param set
		hItem = WM_GetDialogItem(pMsg->hWin, ID_ERROR_PROMPT_BUTTON);
		WM_SetCallback(hItem, ErrorPrompt_Btn_Callback);
        WM_InvalidateWindow(hItem);
		
        //text
        hItem = WM_GetDialogItem(pMsg->hWin, ID_ERROR_PROMPT_TEXT);
        TEXT_SetTextAlign(hItem, GUI_TA_CENTER|GUI_TA_HCENTER);
        //TEXT_SetFont(hItem, &SIF_HZ16_SONGTI);
        sprintf(buffer, "%sE%d", "错误代码:", g_ulErrorCode);
        TEXT_SetText(hItem, buffer);

        // USER END
        break;
    case WM_PAINT:
    {
        //draw warming logo
        GUI_PNG_Draw(_acErrorPrompt_Fail, GUI_COUNTOF(_acErrorPrompt_Fail), 220, 40);
    }
    break;
    case WM_NOTIFY_PARENT:
        Id = WM_GetId(pMsg->hWinSrc);
        NCode = pMsg->Data.v;
        switch (Id) {
        case ID_ERROR_PROMPT_BUTTON: // Notifications sent by 'Sure_Button'
            switch (NCode) {
            case WM_NOTIFICATION_CLICKED:
                // USER START (Optionally insert code for reacting on notification message)
                // USER END
                break;
                case WM_NOTIFICATION_RELEASED:
                {
					GUI_EndDialog(pMsg->hWin, 0);
					g_hActiveWin = Analysis_Menu();
                }
                break;
                // USER START (Optionally insert additional code for further notification handling)
                // USER END
            }
            break;
        }
        break;
        // USER START (Optionally insert additional message handling)
        // USER END
    default:
        WM_DefaultProc(pMsg);
        break;
    }
}

/*********************************************************************
*
*       Public code
*
**********************************************************************
*/
/*********************************************************************
*
*       CreateNextSample_Framewin
*/

//背景窗口 回调函数
void ErrorPrompt_cbBkWin(WM_MESSAGE* pMsg)
{
    switch (pMsg->MsgId)
    {
//        case WM_INIT_DIALOG:
//        {
//            GUI_SetAlpha(NEXT_SMAPLE_ALPHA);
//            GUI_SetColor(NEXT_SMAPLE_ALPHA_COLOR);
//            GUI_FillRect(0, 0, 800, 480);
//            GUI_SetAlpha(0);
//        }
        case WM_PAINT:
        {
            GUI_SetAlpha(30);
            GUI_SetColor(0x00525a4e);
            GUI_FillRect(0, 0, 800, 480);
            GUI_SetAlpha(0);
        }
        break;
        default:
        {
            WM_DefaultProc(pMsg);
        }
        break;
    }
}



WM_HWIN ErrorPrompt_Window(void);
WM_HWIN ErrorPrompt_Window(void) {
    WM_HWIN hWin;
    
    //GUI_Clear();
    Pulic_Hide_Widget(); //隐藏公共部分控件,
    WM_SetCallback(WM_HBKWIN, ErrorPrompt_cbBkWin);

    hWin = GUI_CreateDialogBox(ErrorPrompt_aDialogCreate, GUI_COUNTOF(ErrorPrompt_aDialogCreate), ErrorPrompt_cbDialog, WM_HBKWIN, 0, 0);
    return hWin;
}

// USER START (Optionally insert additional public code)
// USER END

/*************************** End of file ****************************/
