/*********************************************************************
*                                                                    *
*                SEGGER Microcontroller GmbH & Co. KG                *
*        Solutions for real time microcontroller applications        *
*                                                                    *
**********************************************************************
*                                                                    *
* C-file generated by:                                               *
*                                                                    *
*        GUI_Builder for emWin version 5.44                          *
*        Compiled Nov 10 2017, 08:53:57                              *
*        (c) 2017 Segger Microcontroller GmbH & Co. KG               *
*                                                                    *
**********************************************************************
*                                                                    *
*        Internet: www.segger.com  Support: support@segger.com       *
*                                                                    *
**********************************************************************
*/

// USER START (Optionally insert additional includes)
// USER END

#include "DIALOG.h"
#include "Public_menuDLG.h"
#include "Common.h"
/*********************************************************************
*
*       Defines
*
**********************************************************************
*/
#define ID_WINDOW_0 (PAGE_ID_INPUT_USER_NUM + 0x00)
#define ID_TEXT_0 (PAGE_ID_INPUT_USER_NUM + 0x01)
#define ID_EDIT_0 (PAGE_ID_INPUT_USER_NUM + 0x04)
#define ID_BUTTON_0 (PAGE_ID_INPUT_USER_NUM + 0x09)
#define ID_BUTTON_1 (PAGE_ID_INPUT_USER_NUM + 0x0A)


// USER START (Optionally insert additional defines)
// USER END

/*********************************************************************
*
*       Static data
*
**********************************************************************
*/

// USER START (Optionally insert additional static data)
// USER END

/*********************************************************************
*
*       _aDialogCreate
*/
static const GUI_WIDGET_CREATE_INFO _aDialogCreate[] = {
  { WINDOW_CreateIndirect, "AddUserPage", ID_WINDOW_0, 80, 65, 640, 380, 0, 0x0, 0 },
  { TEXT_CreateIndirect, "NewUser", ID_TEXT_0, 128, 160, 120, 20, 0, 0x64, 0 },
  { EDIT_CreateIndirect, "NewUser_e", ID_EDIT_0, 268, 150, 184, 40, 0, 0xa, 0 },
  { BUTTON_CreateIndirect, "CEl", ID_BUTTON_0, 0, 340, 320, 40, 0, 0x0, 0 },
  { BUTTON_CreateIndirect, "Confim", ID_BUTTON_1, 320, 340, 320, 40, 0, 0x0, 0 },
  // USER START (Optionally insert additional widgets)
  // USER END
};

/*********************************************************************
*
*       Static code
*
**********************************************************************
*/

// USER START (Optionally insert additional static code)
static void _ResetPswPageRedrawWidgetType_Callback(WM_MESSAGE* pMsg)
{
    switch (pMsg->MsgId)
    {
    case WM_PAINT:
    {
        GUI_RECT Rect;
        WM_GetClientRect(&Rect);

        if (BUTTON_IsPressed(pMsg->hWin)) {
			switch(WM_GetId(pMsg->hWin)){
				//取消按钮
				case ID_BUTTON_0:
					//填充
					GUI_SetColor(MachInfo.companyInfo.skin.highlightKJSelect);
					GUI_FillRectEx(&Rect);
					
					//设置字符前景和背景色
					GUI_SetColor(MachInfo.companyInfo.skin.highlightKJSelectFont);
					GUI_SetBkColor(MachInfo.companyInfo.skin.highlightKJSelect);
				
					GUI_DispStringInRect(g_ucaLng_Cancel[MachInfo.systemSet.eLanguage],&Rect,GUI_TA_HCENTER|GUI_TA_VCENTER);
				break;
				
				//确认按钮
				case ID_BUTTON_1:
					//填充
					GUI_SetColor(MachInfo.companyInfo.skin.highlightKJSelect);
					GUI_FillRectEx(&Rect);
					
					//设置字符前景和背景色
					GUI_SetColor(MachInfo.companyInfo.skin.highlightKJSelectFont);
					GUI_SetBkColor(MachInfo.companyInfo.skin.highlightKJSelect);
				
					GUI_DispStringInRect(g_ucaLng_Sure[MachInfo.systemSet.eLanguage],&Rect,GUI_TA_HCENTER|GUI_TA_VCENTER);
				break;
				
				default :break;
			}
        }
        else{
			switch(WM_GetId(pMsg->hWin)){
				//取消按钮
				case ID_BUTTON_0:
					GUI_SetColor(GUI_LIGHTGRAY);
					GUI_FillRect(Rect.x0, Rect.y0, Rect.x1, Rect.y1);
					GUI_SetColor(BTN_CHAR_COLOR);
					GUI_SetBkColor(GUI_LIGHTGRAY);
				
					GUI_DispStringInRect(g_ucaLng_Cancel[MachInfo.systemSet.eLanguage],&Rect,GUI_TA_HCENTER|GUI_TA_VCENTER);
				break;
				
				//确认按钮
				case ID_BUTTON_1:
					GUI_SetColor(MachInfo.companyInfo.skin.highlightKJNotSelect);
					GUI_FillRect(Rect.x0, Rect.y0, Rect.x1, Rect.y1);
					GUI_SetColor(MachInfo.companyInfo.skin.highlightKHNotSelectFont);
					GUI_SetBkColor(MachInfo.companyInfo.skin.highlightKJNotSelect);
				
					GUI_DispStringInRect(g_ucaLng_Sure[MachInfo.systemSet.eLanguage],&Rect,GUI_TA_HCENTER|GUI_TA_VCENTER);
				break;
				
				default :break;
			}
        }
    }
    break;
    default:
        BUTTON_Callback(pMsg);
        break;
    }
}



static void _ResetPswPageRedrawWidgetType(WM_MESSAGE* pMsg)
{
    WM_HWIN hItem;
	
	//取消按钮
    hItem = WM_GetDialogItem(pMsg->hWin, ID_BUTTON_0);  
    WM_SetCallback(hItem, _ResetPswPageRedrawWidgetType_Callback);
    WM_InvalidateWindow(hItem);
	
    //确定按钮
    hItem = WM_GetDialogItem(pMsg->hWin, ID_BUTTON_1);  
    WM_SetCallback(hItem, _ResetPswPageRedrawWidgetType_Callback);
    WM_InvalidateWindow(hItem);
}
// USER END

/*********************************************************************
*
*       _cbDialog
*/
static void _cbDialog(WM_MESSAGE * pMsg) {
  WM_HWIN hItem;
  int     NCode;
  int     Id;
  // USER START (Optionally insert additional variables)
	extern WM_HWIN CreateUserManagePage(void);
	extern  MachInfo_s	MachInfo;
	extern  __IO MachRunPara_s       MachRunPara;
	
	static uint8_t MoveWindowFlag = 0;							//是否移动了窗口标志
	static uint8_t MoveWindowYValue = 0;						//移动窗口的Y轴偏移量
	
	GUI_RECT Rect;
    WM_GetClientRect(&Rect);
	char Str[30];
  // USER END

  switch (pMsg->MsgId) {
  case WM_INIT_DIALOG:
    //
    // Initialization of 'NewUser_t'
    //
    hItem = WM_GetDialogItem(pMsg->hWin, ID_TEXT_0);
    TEXT_SetTextAlign(hItem, GUI_TA_RIGHT | GUI_TA_VCENTER);
	TEXT_SetFont(hItem,&HZ_SONGTI_16);
	TEXT_SetText(hItem,g_ucaLng_Analyse_InputUserNum[MachInfo.systemSet.eLanguage]);
    //
    // Initialization of 'NewUser_e'
    //
    hItem = WM_GetDialogItem(pMsg->hWin, ID_EDIT_0);
    EDIT_SetTextAlign(hItem, GUI_TA_HCENTER | GUI_TA_VCENTER);
	EDIT_EnableBlink(hItem,500,1);
	EDIT_SetMaxLen(hItem,PATIENT_ID_MAX_LEN-1);
	
	//重绘按钮样式
	_ResetPswPageRedrawWidgetType(pMsg);
    // USER START (Optionally insert additional code for further widget initialization)
    // USER END
    break;
	
  case WM_PAINT:
	//先设置弹窗和背景为相同的透明度
	GUI_SetAlpha(30);
	GUI_SetColor(0x00525a4e);
	GUI_FillRectEx(&Rect);
	GUI_SetAlpha(0);
  
	//重绘弹窗为圆角矩形
	GUI_SetColor(0x00ffffff);
	GUI_AA_FillRoundedRectEx(&Rect,6);
  
	//重绘顶部标题栏，采用重叠法
	GUI_SetColor(MachInfo.companyInfo.skin.title);
	GUI_AA_FillRoundedRect(Rect.x0,Rect.y0,Rect.x1,Rect.y0+15,6);
	GUI_FillRect(Rect.x0,Rect.y0+10,Rect.x1,Rect.y0+38);
	
	//标题
	GUI_SetFont(&HZ_SONGTI_16);
	GUI_SetColor(MachInfo.companyInfo.skin.titleFont);
	GUI_SetBkColor(MachInfo.companyInfo.skin.title);
	GUI_DispStringHCenterAt(g_ucaLng_Analyse_InputUserNum[MachInfo.systemSet.eLanguage],320,10);
  break;
  
  //键盘更新事件
  case WM_KEYBOARD_UPDATE:
	
	hItem = WM_GetFocusedWindow();
	
	//ASCII码
	if(strlen(pMsg->Data.p) == 1){
		GUI_StoreKeyMsg(*((char*)pMsg->Data.p),1);
	}
  break;
  
  //键盘结束事件
  case WM_KEYBOARD_END:
	  //判断是否移动了窗口，是，则还原
	  if(MoveWindowFlag == 1){
		MoveWindowFlag = 0;
		WM_MoveWindow(pMsg->hWin,0,MoveWindowYValue);
	  }
  break;
	  
  case WM_USER_DATA:
  break;
	
  case WM_NOTIFY_PARENT:
    Id    = WM_GetId(pMsg->hWinSrc);
    NCode = pMsg->Data.v;
    switch(Id) {
    case ID_EDIT_0: // Notifications sent by 'NewUser_e'
      switch(NCode) {
      case WM_NOTIFICATION_CLICKED:
        // USER START (Optionally insert code for reacting on notification message)
        // USER END
        break;
      case WM_NOTIFICATION_RELEASED:
        // USER START (Optionally insert code for reacting on notification message)
			
		//唤出键盘
		WM_SetFocus(pMsg->hWinSrc);
		MachRunPara.keyboardInitJM = KEYBOARD_CHAR;
		CreateKeyboard_Window();
			
        // USER END
        break;
      case WM_NOTIFICATION_VALUE_CHANGED:
        // USER START (Optionally insert code for reacting on notification message)
        // USER END
        break;
      // USER START (Optionally insert additional code for further notification handling)
      // USER END
      }
      break;
    case ID_BUTTON_0: // Notifications sent by 'cel_b'
      switch(NCode) {
      case WM_NOTIFICATION_CLICKED:
        // USER START (Optionally insert code for reacting on notification message)
        // USER END
        break;
      case WM_NOTIFICATION_RELEASED:
        // USER START (Optionally insert code for reacting on notification message)
	  {
			extern WM_HWIN Analysis_Menu(void);
		  
			MachRunPara.flag.requestingPatient = 0;
		  
			GUI_EndDialog(pMsg->hWin, 0);
			g_hActiveWin = Analysis_Menu();
	  }
        break;
      // USER START (Optionally insert additional code for further notification handling)
      // USER END
      }
      break;
    case ID_BUTTON_1: // Notifications sent by 'confim_b'
      switch(NCode) {
      case WM_NOTIFICATION_CLICKED:
        // USER START (Optionally insert code for reacting on notification message)
        // USER END
        break;
      case WM_NOTIFICATION_RELEASED:
	  {
		  extern WM_HWIN Analysis_Menu(void);
		  extern CATGlobalStatus_s CATGlobalStatus;
		  extern osMessageQueueId_t CATQueueOtherHandle;
		  extern osMessageQueueId_t CATQueueHandle;
		  extern osEventFlagsId_t GlobalEventCatGroupHandle;
		  CommonDialogPageData_s DialogPageData = {0};
		  Msg_Head_t BackendMsg = {0};
		  CATQueueInfoBuf_s CATQueueInfoBuf = {0};
		  
			memset(Str,0,PATIENT_ID_MAX_LEN);
			hItem = WM_GetDialogItem(pMsg->hWin,ID_EDIT_0);
			EDIT_GetText(hItem,Str,PATIENT_ID_MAX_LEN);
		  
			if(strlen(Str) == NULL){
				break;
			}
			
			//保存患者编号
			strcpy((char*)MachRunPara.tNextSample.patientID,Str);
			
			GUI_EndDialog(pMsg->hWin, 0);
			g_hActiveWin = CreateDialogPage();
		  
			//保存对话框内容
			DialogPageData.bmpType = BMP_ALARM;
			DialogPageData.confimButt = NO_CONFIM_BUTTON;
			DialogPageData.fun = Analysis_Menu;
			strcpy(DialogPageData.str,g_ucaLng_Analyse_RequestParientInfo[MachInfo.systemSet.eLanguage]);
			
			pMsg->MsgId = WM_USER_DATA;
			pMsg->Data.p = &DialogPageData;
			WM_SendMessage(g_hActiveWin,pMsg);
			
			//先清除网络异常事件标志
			osEventFlagsClear(GlobalEventCatGroupHandle,GLOBAL_EVENT_CAT_CONN_NET_ERR);
			
			//往后台发送消息
			BackendMsg.usCmd = CMD_ANALYSIS_REQUEST_USER_NUM;
			UI_Put_Msg((uint8_t*)&BackendMsg);
			
			CATQueueInfoBuf.msgType = REQUEST_PATIENT_ID_CAT_MSG_TYPE;
			memset(CATQueueInfoBuf.para.Str,0,sizeof(CATQueueInfoBuf.para.Str));
			strcpy(CATQueueInfoBuf.para.Str,(char*)MachRunPara.tNextSample.patientID);
			
			switch(MachInfo.companyInfo.company){
				case COMPANY_YSB:
				{
					//药师帮
					//向第三方服务端请求指定患者编号的患者信息
					osMessageQueuePut(CATQueueOtherHandle,&CATQueueInfoBuf,0, 0);
				}break;
				
				default :
				{
					//向创怀服务端请求指定患者编号的患者信息
					osMessageQueuePut(CATQueueHandle,&CATQueueInfoBuf,0, 0);
				}break;
			}
	  }break;
	}
	break;
    }
    break;
  // USER START (Optionally insert additional message handling)
  // USER END
  default:
    WM_DefaultProc(pMsg);
    break;
  }
}

/*********************************************************************
*
*       Public code
*
**********************************************************************
*/
/*********************************************************************
*
*       CreateResetPswPage
*/
WM_HWIN CreateInputUserNumPage(void);
WM_HWIN CreateInputUserNumPage(void) {
  WM_HWIN hWin;
	
	WM_SetCallback(WM_HBKWIN, NotAlphaBk_cbBkWin);
	Public_Hide_Widget();
	
	Disable_Algo_Task();

  hWin = GUI_CreateDialogBox(_aDialogCreate, GUI_COUNTOF(_aDialogCreate), _cbDialog, WM_HBKWIN, 0, 0);
  return hWin;
}

// USER START (Optionally insert additional public code)
// USER END

/*************************** End of file ****************************/
