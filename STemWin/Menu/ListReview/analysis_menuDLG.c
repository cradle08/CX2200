/*********************************************************************
*                                                                    *
*                SEGGER Microcontroller GmbH & Co. KG                *
*        Solutions for real time microcontroller applications        *
*                                                                    *
**********************************************************************
*                                                                    *
* C-file generated by:                                               *
*                                                                    *
*        GUI_Builder for emWin version 5.44                          *
*        Compiled Nov 10 2017, 08:53:57                              *
*        (c) 2017 Segger Microcontroller GmbH & Co. KG               *
*                                                                    *
**********************************************************************
*                                                                    *
*        Internet: www.segger.com  Support: support@segger.com       *
*                                                                    *
**********************************************************************
*/

// USER START (Optionally insert additional includes)
// USER END

#include "DIALOG.h"
#include "WM.h"
#include "FRAMEWIN.h"
#include "BUTTON.h"
#include "LISTVIEW.h"
//#include "WINDOWS.h"
#include "TEXT.h"
#include "HEADER.h"

#include "cx_menu.h"
#include "Analysis_MenuDLG.h"
#include "Public_menuDLG.h"

// USER START (Optionally insert additional defines)
// USER END

/*********************************************************************
*
*       Static data
*
**********************************************************************
*/
//缓存WBCHGB测试错误码
__IO uint32_t g_ulErrorCode = ERROR_CODE_SUCCESS;


/*********************************************************************
*
*       Defines
*
**********************************************************************
*/
#define WBCHGB_LISTVIEW_LEN             330
#define WBCHGB_LISTVIEW_HEAD_LEN        34
#define WBCHGB_LISTVIEW_COLUMN_LEN      100


// error prompt
//#define GUI_BTN_ERROR_PROMPT_COLOR  0x004FA5FF
// list view
//#define GUI_LISTVIEW_COLOR_GRAY		0x00f7f7f7
//#define GUI_LISTVIEW_COLOR_BLUE		0x00f7f2e8
//#define GUI_LISTVIEW_FRAME_COLOR	0x00cbcbcb

#define GUI_WBCHGB_RESULT_COLOR_GRAY	0x00f7f7f7
#define GUI_WBCHGB_RESULT_COLOR_BLUE    0x00f7f2e8
#define GUI_WBCHGB_RESULT_FRAME_COLOR   0x00cbcbcb

// header
#define GUI_HEADER_COLOR_BLUE		    0x00f1e7d2




//ID
#define ID_WINDOW_ANALYSIS          (GUI_Analysis_Menu_ID + 0x00)
#define ID_BUTTION_WBCHGB_RESULT    (GUI_Analysis_Menu_ID + 0x06)
#define ID_BUTTON_LAST_RECORD       (GUI_Analysis_Menu_ID + 0x07)
#define ID_BUTTON_NEXT_RECORD       (GUI_Analysis_Menu_ID + 0x08)
#define ID_BUTTON_NEXT_SAMPLE       (GUI_Analysis_Menu_ID + 0x09)
#define ID_BUTTON_PRINT             (GUI_Analysis_Menu_ID + 0x0A)
#define ID_BUTTON_PATIENT_INFO      (GUI_Analysis_Menu_ID + 0x0B)
#define ID_TEXT_WBC_PROMPT          (GUI_Analysis_Menu_ID + 0x10)
#define ID_TEXT_HGB_PROMPT          (GUI_Analysis_Menu_ID + 0x11)
#define ID_TEXT_TEST_INFO           (GUI_Analysis_Menu_ID + 0x13)
#define ID_TEXT_WBC_HISTOGRAM       (GUI_Analysis_Menu_ID + 0x14)


 
/*********************************************************************
*
*       _aDialogCreate
*/
static const GUI_WIDGET_CREATE_INFO Analysis_aDialogCreate[] = {
  { WINDOW_CreateIndirect, "",     			ID_WINDOW_ANALYSIS,             10, 60, 780, 400, 0, 0, 0x0 },
  { BUTTON_CreateIndirect, "", 			ID_BUTTION_WBCHGB_RESULT,      10, 60, 300, 330, 0, 0x0, 0 },
  { BUTTON_CreateIndirect, "上一记录",    	ID_BUTTON_LAST_RECORD,          10, 12, 120, 40, 0, 0x0, 0 },
  { BUTTON_CreateIndirect, "下一记录",    	ID_BUTTON_NEXT_RECORD,          144, 12, 120, 40, 0, 0x0, 0 },
  { BUTTON_CreateIndirect, "下一样本测试",  ID_BUTTON_NEXT_SAMPLE,          280, 12, 180, 40, 0, 0x0, 0 },
  { BUTTON_CreateIndirect, "打印",         	ID_BUTTON_PRINT,                515, 12, 120, 40, 0, 0x0, 0 },
  { BUTTON_CreateIndirect, "病人信息",    	ID_BUTTON_PATIENT_INFO,         650, 12, 120, 40, 0, 0x0, 0 },
  { TEXT_CreateIndirect, "",        	ID_TEXT_WBC_PROMPT,         315, 60, 175, 200, 0, 0x0, 0 },
  { TEXT_CreateIndirect, "",        	ID_TEXT_HGB_PROMPT,         315, 265, 175, 125, 0, 0x0, 0 },
  { TEXT_CreateIndirect, "",        		ID_TEXT_TEST_INFO,              495, 60, 280, 110, 0, 0x0, 0 },
  { TEXT_CreateIndirect, "",                ID_TEXT_WBC_HISTOGRAM,          495, 175, 280, 215, 0, 0x0, 0 },
  //{ TEXT_CreateIndirect, "0",                   ID_TEXT_SCALE_0,        520, 425, 25, 15, 0, 0x0, 0 },
  //{ TEXT_CreateIndirect, "100",                 ID_TEXT_SCALE_100,      570, 425, 25, 15, 0, 0x0, 0 },
  //{ TEXT_CreateIndirect, "200",                 ID_TEXT_SCALE_200,      620, 425, 25, 15, 0, 0x0, 0 },
  //{ TEXT_CreateIndirect, "300",                 ID_TEXT_SCALE_300,      670, 425, 25, 15, 0, 0x0, 0 },
  //{ TEXT_CreateIndirect, "FL",                  ID_TEXT_SCALE_FL,       720, 425, 25, 15, 0, 0x0, 0 },

};

/*********************************************************************
*
*       Static code
*
**********************************************************************
*/

/*
    test info callback
*/
#define WBCHGB_TEXT_HEADR_BK_COLOR	0x00f1e7d2
static void WBCHGB_ErrorPrompt_Text_Callback(WM_MESSAGE* pMsg)
{
	const unsigned char RoundRadius  = 3;  //显示区域圆角半径
	const unsigned char HeaderLen	 = 34; //显示头高度
    const unsigned char Leght	     = 175; //宽度
    
	GUI_RECT TempRect = {0};
	
	switch (pMsg->MsgId)
    {
        case WM_PAINT:
        {
            GUI_RECT Rect;
            GUI_GetClientRect(&Rect);
            //set hear background
            GUI_SetColor(WBCHGB_TEXT_HEADR_BK_COLOR);
            GUI_AA_FillRoundedRect(Rect.x0, Rect.y0, Rect.x0+Leght, Rect.y0+RoundRadius+HeaderLen, RoundRadius);
			//set tail background
            GUI_SetColor(GUI_TEXT_BK_COLOR);
            GUI_AA_FillRoundedRect(Rect.x0, Rect.y1 - HeaderLen, Rect.x1, Rect.y1, RoundRadius);
			
            //set body and tail(expect RoundRadius)background
			GUI_SetColor(GUI_TEXT_BK_COLOR);
            GUI_AA_FillRoundedRect(Rect.x0, Rect.y0+HeaderLen, Rect.x1, Rect.y1-RoundRadius, 0);
			
			//draw frame
            GUI_SetColor(GUI_TEXT_FRAME_COLOR);
            GUI_DrawHLine(Rect.y0+HeaderLen, Rect.x0, Rect.x1);
            GUI_AA_DrawRoundedRect(Rect.x0, Rect.y0, Rect.x1, Rect.y1, RoundRadius);
            
            //char display
            TempRect.x0 = Rect.x0; TempRect.y0 = Rect.y0; //头显示区域
            TempRect.x1 = Rect.x1; TempRect.y1 = HeaderLen;
            GUI_SetColor(GUI_BLACK);
			GUI_SetBkColor(WBCHGB_TEXT_HEADR_BK_COLOR); 
			if(ID_TEXT_WBC_PROMPT == WM_GetId(pMsg->hWin))
			{ 
                //显示头内容
				GUI_DispStringInRect("白细胞异常提示", &TempRect, GUI_TA_HCENTER | GUI_TA_VCENTER);
				//WBC异常信息显示区域及内容
                TempRect.x0 = Rect.x0; TempRect.y0 = Rect.y0 + HeaderLen;
                TempRect.x1 = Rect.x1; TempRect.y1 = Rect.y1;
                GUI_SetColor(GUI_BLACK);
                GUI_SetBkColor(GUI_TEXT_BK_COLOR);
                GUI_DispStringInRect((char*)g_tUI_Info.tWBCHGB_TestInfo.ucaWBC_ErrorPrompt, &TempRect, GUI_TA_HCENTER | GUI_TA_TOP);
                
			}else if(ID_TEXT_HGB_PROMPT == WM_GetId(pMsg->hWin)){
				
                //显示头内容
				GUI_DispStringInRect("血红蛋白异常提示", &TempRect, GUI_TA_HCENTER | GUI_TA_VCENTER);
              	//HGB异常信息显示区域及内容
                TempRect.x0 = Rect.x0; TempRect.y0 = Rect.y0 + HeaderLen;
                TempRect.x1 = Rect.x1; TempRect.y1 = Rect.y1;
                GUI_SetColor(GUI_BLACK);
                GUI_SetBkColor(GUI_TEXT_BK_COLOR);
                GUI_DispStringInRect((char*)g_tUI_Info.tWBCHGB_TestInfo.ucaHGB_ErrorPrompt, &TempRect, GUI_TA_HCENTER | GUI_TA_TOP);    
			}    
        }
        break;
        default:
            TEXT_Callback(pMsg);
        break;
    }
}


/*
    test info callback
*/
static void TestInfo_TEXT_Callback(WM_MESSAGE* pMsg)
{
    extern __IO UI_Info_t	g_tUI_Info;
//    const unsigned char SpareLineLen = 8; //分割线宽度
    const unsigned char RoundRadius  = 3; //显示区域圆角半径
//    unsigned char i = 0;
    
    /*
    char testinfo[4][35] = { 
		{"样本编号: CBC-0001"},
        {"模式: WBC+HGB"},
        {"姓名: test"},
        {"检验时间: 2020/11/02 14:15"} };
    */
    
    char buffer[35] = { 0 };
    char testinfo[4][35] = {
        {"姓名: %s"},
        {"年龄: %d       性别: %s"},
        {"样本编号: %s"},
        {"检验时间: %s"} };

    //char testinfo[120] = {"样本编号: CBC-0001模式: WBC+HGB姓名: test检验时间: 2020/11/02 14:15"};

    switch (pMsg->MsgId)
    {
        case WM_PAINT:
        {
            GUI_RECT Rect;
            GUI_GetClientRect(&Rect);
            //background
            GUI_SetColor(GUI_TEXT_BK_COLOR);
            GUI_AA_FillRoundedRect(Rect.x0, Rect.y0, Rect.x1, Rect.y1, RoundRadius);
            //frame board
            GUI_SetColor(GUI_TEXT_FRAME_COLOR);
            GUI_AA_DrawRoundedRect(Rect.x0, Rect.y0, Rect.x1, Rect.y1, RoundRadius);
            //spare line
            /*
            GUI_SetColor(GUI_SPARE_LINE_COLOR_YELLOW);
            GUI_AA_FillRoundedRect(Rect.x0, Rect.y0, SpareLineLen, Rect.y1, RoundRadius);
            GUI_FillRect(RoundRadius, Rect.y0, SpareLineLen, Rect.y1);
            */
            //for (i = RoundRadius + 1; i < SpareLineLen; i++)
            //{
               // GUI_DrawVLine(Rect.x0 + i, Rect.y0, Rect.y1);
            //}
            //show msg
            GUI_SetColor(GUI_BLACK);
            GUI_SetBkColor(GUI_TEXT_BK_COLOR);
            //for (i = 0; i < 4; i++) //4行信息
            //{
                //GUI_DispStringAt(&testinfo[i][0], Rect.x0 + 20, Rect.y0 + 10 + i * 25);
                //Rect.x0 = Rect.x0 + SpareLineLen + 10;
                //GUI_DispStringInRect(testinfo, &Rect, GUI_TA_LEFT | GUI_TA_VCENTER);
            //}
            //姓名
            memset(buffer, 0, sizeof(buffer));
            sprintf(buffer, testinfo[0], (char*)g_tUI_Info.tWBCHGB_TestInfo.ucaName);  //sprintf(buffer, testinfo[0], "张三");
            GUI_DispStringAt(buffer, Rect.x0 + 20, Rect.y0 + 10);

            //性别
            memset(buffer, 0, sizeof(buffer));
            if (SEX_TYPE_MALE == g_tUI_Info.tWBCHGB_TestInfo.eSex) //男
            {
                sprintf(buffer, testinfo[1], g_tUI_Info.tWBCHGB_TestInfo.ucAge,(char*)g_ucaLng_SexMale[g_tUI_Info.tSystemSet.eLanguage]);  //sprintf(buffer, testinfo[1], 25, (char*)"男");
            }
            else if(SEX_TYPE_FEMALE == g_tUI_Info.tWBCHGB_TestInfo.eSex) //女
            {

                printf(buffer, testinfo[1], g_tUI_Info.tWBCHGB_TestInfo.ucAge, (char*)g_ucaLng_SexFemale[g_tUI_Info.tSystemSet.eLanguage]);  //sprintf(buffer, testinfo[1], 25, (char*)"男");
            }
            GUI_DispStringAt(buffer, Rect.x0 + 20, Rect.y0 + 10 + 1*25);

            //样本编号
            memset(buffer, 0, sizeof(buffer));
            sprintf(buffer, testinfo[2], (char*)&g_tUI_Info.tWBCHGB_TestInfo.ucaSampleSN);
            GUI_DispStringAt(buffer, Rect.x0 + 20, Rect.y0 + 10 + 2 * 25);

            //检测时间
            memset(buffer, 0, sizeof(buffer));
            sprintf(buffer, testinfo[3], (char*)&g_tUI_Info.tWBCHGB_TestInfo.ucaDateTime);
            GUI_DispStringAt(buffer, Rect.x0 + 20, Rect.y0 + 10 + 3 * 25);
        }
        break;
        default:
            TEXT_Callback(pMsg);
        break;
    }
}



/*
*    wbc histogram callback
*/
#define SCALE_CHAR_NUM      5
static void WBC_Histogram_TEXT_Callback(WM_MESSAGE* pMsg)
{
    extern __IO UI_Info_t	g_tUI_Info;
    int MaxPos_x = 0, MaxPos_y = 175;
//    const unsigned char SpareLineLen = 8; //分割线宽度
    const unsigned char RoundRadius = 3; //显示区域圆角半径
    unsigned short i = 0;
    char buffer[10] = {0};
    GUI_POINT Point[GRAPH_DATA_LEN + 1] = {0};
    char FL_Scale[SCALE_CHAR_NUM][4] = {
        {"0"},
        {"100"},
        {"200"},
        {"300"},
        {"400"},
        /*{"FL"}*/ };

    switch (pMsg->MsgId)
    {
    case WM_PAINT:
    {
        GUI_RECT Rect;
        GUI_GetClientRect(&Rect);
        
        /* draw back */
        GUI_SetColor(GUI_TEXT_BK_COLOR);
        GUI_Clear();
        //GUI_FillRectEx(&Rect);
        GUI_AA_FillRoundedRect(Rect.x0, Rect.y0, Rect.x1, Rect.y1, RoundRadius);
        GUI_SetColor(GUI_TEXT_FRAME_COLOR);
        GUI_AA_DrawRoundedRect(Rect.x0, Rect.y0, Rect.x1, Rect.y1, RoundRadius);
        //spare line
        /*
        GUI_SetColor(GUI_SPARE_LINE_COLOR_GREEN);
        GUI_AA_FillRoundedRect(Rect.x0, Rect.y0, SpareLineLen, Rect.y1, RoundRadius);
        GUI_FillRect(SpareLineLen - RoundRadius, Rect.y0, SpareLineLen, Rect.y1);
        */
        //for (i = RoundRadius + 1; i < SpareLineLen; i++)
        //{
            //GUI_DrawVLine(Rect.x0 + i, Rect.y0, Rect.y1);
        //}
        
        /* show mode */
        GUI_SetColor(GUI_BLACK);
        GUI_FillRect(Rect.x0 + 15, Rect.y0 + 10, 50, 30);
        GUI_SetBkColor(GUI_BLACK);
        GUI_SetColor(GUI_WHITE);
        GUI_DispStringAt("WBC", Rect.x0 + 22, Rect.y0 + 12);
        //draw x y alxis
        GUI_SetColor(GUI_BLACK);
        GUI_DrawVLine(20, 40, 175);     // y
        GUI_DrawHLine(175, 20, 276);    // x
        
        /* draw dot line, 135 hight of histogram */
        GUI_SetColor(GUI_GRAY);
        for (i = 0; i < 135; i++)
        {
            if ((i / 5) % 2 == 0)
            {
                GUI_DrawPoint(20 + g_tUI_Info.tWBCHGB_TestInfo.fLines[0], 175 - i); 
                GUI_DrawPoint(20 + g_tUI_Info.tWBCHGB_TestInfo.fLines[1], 175 - i);
                GUI_DrawPoint(20 + g_tUI_Info.tWBCHGB_TestInfo.fLines[2], 175 - i);
            }
        }
        
        /* draw histogram */
        GUI_SetColor(HISTOGROM_FILL_COLOR);
        for (i = 0; i < GRAPH_DATA_LEN; i++)
        {
            //yPoint[i] = 175 - g_tUI_Info.tWBCHGB_TestInfo.fWBC_Histogram[i];
            Point[i].x = 20 + i;
            Point[i].y = 175 - g_tUI_Info.tWBCHGB_TestInfo.fWBC_Histogram[i];
            
            //get MaxPos y axis
            if(MaxPos_y > Point[i].y) 
            {
                MaxPos_y = Point[i].y;
                MaxPos_x = i;
            }
        }
        //最后一个点(256+1)的Y值必须位175（x轴上），否则调用GUI_AA_FillPolygon， 会出现底部一段为空
        Point[i].y = 175;
        Point[i].x = 20 + i;
        GUI_AA_FillPolygon(Point, GRAPH_DATA_LEN+1, 0, 0); //画直方图
                
        /* show max fl at max x, y axis */
        GUI_SetColor(GUI_BLACK);
        GUI_SetBkColor(GUI_TEXT_BK_COLOR);
        memset((void*)buffer, 0, sizeof(buffer));
        sprintf(buffer, "%0.2f", g_tUI_Info.tWBCHGB_TestInfo.fWbcMaxPos);
        //set x y
        if(MaxPos_x < 40) //to left
        {
            MaxPos_x = 40;
        }else if(MaxPos_x > 220) //too right
        {
            MaxPos_x = 220;
        }
        GUI_DispStringAt(buffer, MaxPos_x, MaxPos_y - 20);
        
        /* draw fl scale value */
        GUI_SetColor(GUI_BLACK);
        GUI_SetBkColor(GUI_TEXT_BK_COLOR);
        //
        GUI_DispStringAt(&FL_Scale[0][0], 20, 185);         // 0
        GUI_DispStringAt(&FL_Scale[1][0], 20 + 50, 180);    // 100
        GUI_DispStringAt(&FL_Scale[2][0], 20 + 115, 180);   // 200
        GUI_DispStringAt(&FL_Scale[3][0], 20 + 180, 180);   // 300
        GUI_DispStringAt(&FL_Scale[4][0], 20 + 230, 180);   // 400
        //
        GUI_SetColor(GUI_RED);
        for(i = 1; i <SCALE_CHAR_NUM; i++)
        {
            GUI_DrawVLine(20 + i * 64, 172, 175); //64->100 fl, scale for fl(100, 200, 300, 400)
        }
        //GUI_DispStringAt(&FL_Scale[i][0], Rect.x0 + 20 + i * 64, Rect.y0 + 185); //FL
    }
    break;
    default:
        TEXT_Callback(pMsg);
        break;
    }
}



/*
*  analysis  btn callback
*/
static void Analysis_Btn_Callback(WM_MESSAGE* pMsg)
{
    const unsigned char RoundRadius = 20; //显示区域圆角半径
    switch (pMsg->MsgId)
    {
    case WM_PAINT:
    {
        GUI_RECT Rect;
        WM_GetClientRect(&Rect);

        if (BUTTON_IsPressed(pMsg->hWin)) {
                 
            //draw frame
            GUI_SetColor(GUI_BTN_PRESS_COLOR); //填充背景颜色
            GUI_AA_FillRoundedRect(Rect.x0, Rect.y0, Rect.x1, Rect.y1, RoundRadius);
            
            GUI_SetColor(GUI_BTN_FRAME_COLOR); //画框
            GUI_AA_DrawRoundedRect(Rect.x0, Rect.y0, Rect.x1, Rect.y1, RoundRadius);
            
            //
            GUI_SetColor(GUI_BTN_PRESS_CHAR_COLOR);
            GUI_SetBkColor(GUI_BTN_PRESS_COLOR);
            //
            if (ID_BUTTON_LAST_RECORD == WM_GetId(pMsg->hWin))
            {
                GUI_PNG_Draw(_acanalysis_record_prev_btn, GUI_COUNTOF(_acanalysis_record_prev_btn), 20, 14 );
                GUI_DispStringAt("上一记录", Rect.x0 + 35, Rect.y0 + 12);
            }
            else if (ID_BUTTON_NEXT_RECORD == WM_GetId(pMsg->hWin)) {
                GUI_PNG_Draw(_acanalysis_record_next_btn, GUI_COUNTOF(_acanalysis_record_next_btn), 90, 14);
                GUI_DispStringAt("下一记录", Rect.x0 + 20, Rect.y0 + 12);
            }
            else if (ID_BUTTON_NEXT_SAMPLE == WM_GetId(pMsg->hWin)) {

                GUI_DispStringInRect("下一样本测试", &Rect, GUI_TA_HCENTER | GUI_TA_VCENTER);
            }
            else if (ID_BUTTON_PRINT == WM_GetId(pMsg->hWin)) {

                GUI_DispStringInRect("打印", &Rect, GUI_TA_HCENTER | GUI_TA_VCENTER);
            }
            else if (ID_BUTTON_PATIENT_INFO == WM_GetId(pMsg->hWin)) {

                GUI_DispStringInRect("病人信息", &Rect, GUI_TA_HCENTER | GUI_TA_VCENTER);
            }
        }
        else {
            
            //填充颜色
            GUI_SetColor(GUI_BTN_RELEASE_COLOR);
            GUI_AA_FillRoundedRect(Rect.x0, Rect.y0, Rect.x1, Rect.y1, RoundRadius);
            GUI_SetColor(GUI_BTN_FRAME_COLOR); //画框
            GUI_AA_DrawRoundedRect(Rect.x0, Rect.y0, Rect.x1, Rect.y1, RoundRadius);
            
            //
            GUI_SetColor(GUI_BTN_RELEASE_CHAR_COLOR);
            GUI_SetBkColor(GUI_BTN_RELEASE_COLOR);

            if (ID_BUTTON_LAST_RECORD == WM_GetId(pMsg->hWin))
            {
                GUI_PNG_Draw(_acanalysis_record_prev_btn, GUI_COUNTOF(_acanalysis_record_prev_btn), 20, 14);
                GUI_DispStringAt("上一记录", Rect.x0 + 35, Rect.y0 + 12);
            }
            else if (ID_BUTTON_NEXT_RECORD == WM_GetId(pMsg->hWin)) {

                GUI_PNG_Draw(_acanalysis_record_next_btn, GUI_COUNTOF(_acanalysis_record_next_btn), 90, 14);
                GUI_DispStringAt("下一记录", Rect.x0 + 20, Rect.y0 + 12);
            }
            else if (ID_BUTTON_NEXT_SAMPLE == WM_GetId(pMsg->hWin)) {

                GUI_DispStringInRect("下一样本测试", &Rect, GUI_TA_HCENTER | GUI_TA_VCENTER);
            }
            else if (ID_BUTTON_PRINT == WM_GetId(pMsg->hWin)) {

                GUI_DispStringInRect("打印", &Rect, GUI_TA_HCENTER | GUI_TA_VCENTER);
            }
            else if (ID_BUTTON_PATIENT_INFO == WM_GetId(pMsg->hWin)) {

                GUI_DispStringInRect("病人信息", &Rect, GUI_TA_HCENTER | GUI_TA_VCENTER);
            }
        }
    }
    break;
    default:
        BUTTON_Callback(pMsg);
        break;
    }
}

/*
*  添加报警信息及数值 到显示buffer
*/
void Display_Result_Info(char *pBuffer, char Index, __IO WBCHGB_TestInfo_t *ptWBCHGB_TestInfo)
{
    if(Index >= WBCHGB_RST_END){
        LOG_Error("Index Morn That %d", WBCHGB_RST_END);
        return;
    }
    
    //根据报警信息和数值，合成显示内容
    switch(ptWBCHGB_TestInfo->ucaWBCHGB_RstAlert[Index])
    {
        case WBCHGB_ALERT_NORMAL:
        {
            sprintf(pBuffer, "%0.2f", ptWBCHGB_TestInfo->fWBCHGB_RstData[Index]);
        }
        break;
        case WBCHGB_ALERT_SMALL:
        {
            sprintf(pBuffer, "%0.2f↓", ptWBCHGB_TestInfo->fWBCHGB_RstData[Index]);
        }
        break;
        case WBCHGB_ALERT_BIG:
        {
            sprintf(pBuffer, "%0.2f↑", ptWBCHGB_TestInfo->fWBCHGB_RstData[Index]);
        }
        break;
        case WBCHGB_ALERT_REVIEW:
        {
            sprintf(pBuffer, "%0.2f?", ptWBCHGB_TestInfo->fWBCHGB_RstData[Index]);
        }
        break;
        case WBCHGB_ALERT_REVIEW_SMALL:
        {
            sprintf(pBuffer, "%0.2f?↓", ptWBCHGB_TestInfo->fWBCHGB_RstData[Index]);
        }
        break;
        case WBCHGB_ALERT_REVIEW_BIG:
        {
            sprintf(pBuffer, "%0.2f?↑", ptWBCHGB_TestInfo->fWBCHGB_RstData[Index]);
        }
        break;
        case WBCHGB_ALERT_INVALID:
        {
            sprintf(pBuffer, "***");
        }
        break;        
    }
    
}    


/*
*  analysis  btn callback
*/
static void WBCHGB_Result_Btn_Callback(WM_MESSAGE* pMsg)
{
    const unsigned char RoundRadius = 3;   //显示区域圆角半径
    const unsigned char HeaderHigh  = 34;  //显示头高度
    const unsigned char LineHigh    = 37;  //每行高度
    const unsigned char LineLen     = 100; //每一小格的长度
    char buffer[8] = {0};
    char i = 0, j = 0;
    GUI_RECT TempRect;
    
    const char ucaParamBuf[WBCHGB_RST_END-1][8] = {
        "WBC", "Gran#", "Mid#", "Lym#", "Gran%", "Mid%", "Lym%",
    };
    const char ucaUnitBuf[WBCHGB_RST_END-1][8] = {
        "10^9/L", "10^9/L", "10^9/L", "10^9/L", "%", "%", "%",
    };
    
    
    //
    switch (pMsg->MsgId)
    {
    case WM_PAINT:
    {
        GUI_RECT Rect;
        WM_GetClientRect(&Rect);
        
        //画头，一行
        for(i = 0; i < 3; i++)
        {     
            //背景显示区域
            TempRect.x0 = Rect.x0 + i*LineLen;
            TempRect.y0 = Rect.y0;
            TempRect.x1 = TempRect.x0 + LineLen;
            TempRect.y1 = TempRect.y0 + HeaderHigh;
            
            GUI_SetColor(GUI_HEADER_COLOR_BLUE);
            if(i == 0)
            {
                //填充背景
                GUI_AA_FillRoundedRect(TempRect.x0, TempRect.y0, TempRect.x1, TempRect.y1+RoundRadius, RoundRadius);
                //显示字符
                GUI_SetColor(GUI_BLACK);
                GUI_SetBkColor(GUI_HEADER_COLOR_BLUE);
                GUI_DispStringInRect("参数", &TempRect, GUI_TA_HCENTER | GUI_TA_VCENTER);
            }else if(i == 1){
                GUI_AA_FillRoundedRect(TempRect.x0, TempRect.y0, TempRect.x1, TempRect.y1, 0);
                //显示字符
                GUI_SetColor(GUI_BLACK);
                GUI_SetBkColor(GUI_HEADER_COLOR_BLUE);
                GUI_DispStringInRect("结果", &TempRect, GUI_TA_HCENTER | GUI_TA_VCENTER);
            }else if(i == 2){
                GUI_AA_FillRoundedRect(TempRect.x0, TempRect.y0, TempRect.x1, TempRect.y1+RoundRadius, RoundRadius);
                //显示字符
                GUI_SetColor(GUI_BLACK);
                GUI_SetBkColor(GUI_HEADER_COLOR_BLUE);
                GUI_SetColor(GUI_BLACK);
                GUI_SetBkColor(GUI_HEADER_COLOR_BLUE);
                GUI_DispStringInRect("单位", &TempRect, GUI_TA_HCENTER | GUI_TA_VCENTER);
            }
        }
        //画尾，HGB一行
        for(i = 0; i < 3; i++)
        {     
            //设置字体及背景显示区域
            TempRect.x0 = Rect.x0 + i*LineLen;
            TempRect.y0 = Rect.y0 + HeaderHigh + 7*LineHigh;
            TempRect.x1 = TempRect.x0 + LineLen;
            TempRect.y1 = TempRect.y0 + LineHigh;
            
            GUI_SetColor(GUI_WBCHGB_RESULT_COLOR_BLUE);
            if(i == 0)
            {
                GUI_AA_FillRoundedRect(TempRect.x0, TempRect.y0 - RoundRadius, TempRect.x1, TempRect.y1, RoundRadius);
                GUI_SetColor(GUI_BLACK);
                GUI_SetBkColor(GUI_WBCHGB_RESULT_COLOR_BLUE);
                GUI_DispStringInRect("HGB", &TempRect, GUI_TA_HCENTER | GUI_TA_VCENTER);
            }else if(i == 1){
               
                GUI_AA_FillRoundedRect(TempRect.x0, TempRect.y0, TempRect.x1, TempRect.y1, 0);
                GUI_SetColor(GUI_BLACK);
                GUI_SetBkColor(GUI_WBCHGB_RESULT_COLOR_BLUE);
                memset(buffer, 0, 8);
                sprintf(buffer, "%0.2f", g_tUI_Info.tWBCHGB_TestInfo.fWBCHGB_RstData[WBCHGB_RST_HGB]);
                GUI_DispStringInRect("12", &TempRect, GUI_TA_HCENTER | GUI_TA_VCENTER);
            }else if(i == 2){
                GUI_AA_FillRoundedRect(TempRect.x0, TempRect.y0 - RoundRadius, TempRect.x1, TempRect.y1, RoundRadius);
                GUI_SetColor(GUI_BLACK);
                GUI_SetBkColor(GUI_WBCHGB_RESULT_COLOR_BLUE);
                GUI_DispStringInRect("g/L", &TempRect, GUI_TA_HCENTER | GUI_TA_VCENTER);
            }
        }
        
        //画WBC结果
        for(i = 0; i < 3; i++) //三列
        {    
            for(j = 0; j < 7; j++) //中间七行
            {                
                //操作区域
                TempRect.x0 = Rect.x0 + i*LineLen;
                TempRect.y0 = Rect.y0 + HeaderHigh + j*LineHigh;
                //
                TempRect.x1 = TempRect.x0 + LineLen;
                TempRect.y1 = TempRect.y0 + LineHigh;
                
                //填充背景
                if(j%2 == 0)
                {
                    GUI_SetColor(GUI_WBCHGB_RESULT_COLOR_GRAY); //设置背景填充颜色
                    GUI_AA_FillRoundedRect(TempRect.x0, TempRect.y0, TempRect.x1, TempRect.y1, 0);
                    GUI_SetBkColor(GUI_WBCHGB_RESULT_COLOR_GRAY); //为显示字符，设置背景颜色
                }else{
                    //GUI_SetColor(GUI_BLACK);
                    GUI_SetColor(GUI_WBCHGB_RESULT_COLOR_BLUE);  //设置背景填充颜色
                    GUI_AA_FillRoundedRect(TempRect.x0, TempRect.y0, TempRect.x1, TempRect.y1, 0);   
                    GUI_SetBkColor(GUI_WBCHGB_RESULT_COLOR_BLUE); //为显示字符，设置背景颜色                     
                }       
                
                //显示字符
                GUI_SetColor(GUI_BLACK);
                if(i == 0) //结果类型
                {
                    GUI_DispStringInRect(ucaParamBuf[j], &TempRect, GUI_TA_HCENTER | GUI_TA_VCENTER);
                }else if(i == 1){ //结果大小
                    memset(buffer, 0, 8);
                    Display_Result_Info(buffer, j, &g_tUI_Info.tWBCHGB_TestInfo);
                    //sprintf(buffer, "%4.2f", g_tUI_Info.tWBCHGB_TestInfo.fWBCHGB_RstData[j]);
                    GUI_DispStringInRect(buffer, &TempRect, GUI_TA_HCENTER | GUI_TA_VCENTER);
                }else if(i == 2){   //结果单位
                    GUI_DispStringInRect(ucaUnitBuf[j], &TempRect, GUI_TA_HCENTER | GUI_TA_VCENTER);
                } 
            }
        }
        //画分割线,横线, 10条
        GUI_SetColor(GUI_WBCHGB_RESULT_FRAME_COLOR);
        GUI_DrawHLine(Rect.y0, Rect.x0, Rect.x1); //第一条
        //GUI_DrawHLine(Rect.y0+HeaderHigh, Rect.x0, Rect.x1); //第二条
        for(i = 0; i < 9; i++)
        {
            GUI_DrawHLine(Rect.y0+HeaderHigh+i*LineHigh, Rect.x0, Rect.x1);
            if(i == 8)  GUI_DrawHLine(Rect.y0+HeaderHigh+i*LineHigh - 1, Rect.x0, Rect.x1);
        }
        //画竖线，4条
        GUI_DrawVLine(Rect.x0, Rect.y0, Rect.y1);
        GUI_DrawVLine(Rect.x0+LineLen, Rect.y0+HeaderHigh, Rect.y1);
        GUI_DrawVLine(Rect.x0+LineLen*2, Rect.y0+HeaderHigh, Rect.y1);
        GUI_DrawVLine(Rect.x0+LineLen*3 - 1, Rect.y0, Rect.y1);
        
        
    }
    break;
    default:
        BUTTON_Callback(pMsg);
        break;
    }
}




/*
* 初始化回调
*/
static void Analysis_Msg_Init(WM_MESSAGE* pMsg)
{
    extern __IO UI_Info_t	g_tUI_Info;
    WM_HWIN hItem;
//    int i = 0, j = 0;
//    char ucBuffer[10] = { 0 };

    //WBC HGB Result
    hItem = WM_GetDialogItem(pMsg->hWin, ID_BUTTION_WBCHGB_RESULT);
    WM_SetCallback(hItem, WBCHGB_Result_Btn_Callback);
    WM_InvalidateWindow(hItem);

    //
    // Initialization of 'wbc prompt '
    //
    hItem = WM_GetDialogItem(pMsg->hWin, ID_TEXT_WBC_PROMPT);
    WM_SetCallback(hItem, WBCHGB_ErrorPrompt_Text_Callback);
    WM_InvalidateWindow(hItem);

    // Initialization of 'HGB prompt'
    hItem = WM_GetDialogItem(pMsg->hWin, ID_TEXT_HGB_PROMPT);
    WM_SetCallback(hItem, WBCHGB_ErrorPrompt_Text_Callback);
    WM_InvalidateWindow(hItem);
    
    // test info
    hItem = WM_GetDialogItem(pMsg->hWin, ID_TEXT_TEST_INFO);
    WM_SetCallback(hItem, TestInfo_TEXT_Callback);
    WM_InvalidateWindow(hItem);

    // wbc histogram info
    hItem = WM_GetDialogItem(pMsg->hWin, ID_TEXT_WBC_HISTOGRAM);
    WM_SetCallback(hItem, WBC_Histogram_TEXT_Callback);
    WM_InvalidateWindow(hItem);

    // last record btn
    hItem = WM_GetDialogItem(pMsg->hWin, ID_BUTTON_LAST_RECORD);  
    //WM_SetCallback(hItem, LastRecord_Btn_Callback);     
    WM_SetCallback(hItem, Analysis_Btn_Callback);
    WM_InvalidateWindow(hItem);
    
    // next record btn
    hItem = WM_GetDialogItem(pMsg->hWin, ID_BUTTON_NEXT_RECORD);  
    //WM_SetCallback(hItem, LastRecord_Btn_Callback);     
    WM_SetCallback(hItem, Analysis_Btn_Callback);
    WM_InvalidateWindow(hItem);
    
    // next sample btn
    hItem = WM_GetDialogItem(pMsg->hWin, ID_BUTTON_NEXT_SAMPLE);
    //WM_SetCallback(hItem, NextTest_Btn_Callback);
    WM_SetCallback(hItem, Analysis_Btn_Callback);
    WM_InvalidateWindow(hItem);

  
    // print btn
    hItem = WM_GetDialogItem(pMsg->hWin, ID_BUTTON_PRINT);
    //WM_SetCallback(hItem, Print_Btn_Callback);
    WM_SetCallback(hItem, Analysis_Btn_Callback);
    WM_InvalidateWindow(hItem);

    // patient info btn
    hItem = WM_GetDialogItem(pMsg->hWin, ID_BUTTON_PATIENT_INFO);
    //WM_SetCallback(hItem, TesterInfo_Btn_Callback);
    WM_SetCallback(hItem, Analysis_Btn_Callback);
    WM_InvalidateWindow(hItem);

}




/*
*   数据更新
*/
static void Analysis_Msg_Updata(WM_MESSAGE* pMsg)
{
    extern __IO UI_Info_t	g_tUI_Info;
    WM_HWIN hItem;
    int i = 0, j = 0;
    char ucBuffer[10] = { 0 };

    //
    hItem = WM_GetDialogItem(pMsg->hWin, ID_BUTTION_WBCHGB_RESULT);
    WM_InvalidateWindow(hItem);
    //WM_DisableWindow(hItem);

    // wbc prompt listview
    hItem = WM_GetDialogItem(pMsg->hWin, ID_TEXT_WBC_PROMPT);
    WM_InvalidateWindow(hItem);

    // HGB prompt listview
    hItem = WM_GetDialogItem(pMsg->hWin, ID_TEXT_HGB_PROMPT);
    WM_InvalidateWindow(hItem);

    // test info
    hItem = WM_GetDialogItem(pMsg->hWin, ID_TEXT_TEST_INFO);
    //WM_SetCallback(hItem, TestInfo_TEXT_Callback);
    WM_InvalidateWindow(hItem);

    // wbc histogram info
    hItem = WM_GetDialogItem(pMsg->hWin, ID_TEXT_WBC_HISTOGRAM);
    //WM_SetCallback(hItem, WBC_Histogram_TEXT_Callback);
    WM_InvalidateWindow(hItem);

    // last record btn
    hItem = WM_GetDialogItem(pMsg->hWin, ID_BUTTON_LAST_RECORD);   
    //WM_SetCallback(hItem, Analysis_Btn_Callback);
    //WM_InvalidateWindow(hItem);
    if(g_tUI_Info.tWBCHGB_TestInfo.ulCurDataSN <= g_tUI_Info.tDataManage.ulFirstSN) //已是第一条
    {
        WM_DisableWindow(hItem);
    }else{
        WM_EnableWindow(hItem);
    }
    
    // next record btn
    hItem = WM_GetDialogItem(pMsg->hWin, ID_BUTTON_NEXT_RECORD);
    //WM_SetCallback(hItem, Analysis_Btn_Callback);
    //WM_InvalidateWindow(hItem);
    if(g_tUI_Info.tWBCHGB_TestInfo.ulCurDataSN + 1 >= g_tUI_Info.tDataManage.ulLastestSN) //已是最后一条记录，失能下一记录
    {
        WM_DisableWindow(hItem);
    }else{
        WM_EnableWindow(hItem);
    }
    
    // next sample btn
//    hItem = WM_GetDialogItem(pMsg->hWin, ID_BUTTON_NEXT_SAMPLE);
//    WM_InvalidateWindow(hItem);


    // print btn
    hItem = WM_GetDialogItem(pMsg->hWin, ID_BUTTON_PRINT);
    //WM_SetCallback(hItem, Analysis_Btn_Callback);
    //WM_InvalidateWindow(hItem);
    if((g_tUI_Info.tDataManage.ulFirstSN == 0 && g_tUI_Info.tDataManage.ulLastestSN == 0) || g_tUI_Info.tDataManage.ulLastestSN == 0) //无记录
    {
        WM_DisableWindow(hItem);
    }else{
        WM_EnableWindow(hItem);
    }

    // patient info btn
    //hItem = WM_GetDialogItem(pMsg->hWin, ID_BUTTON_PATIENT_INFO);
    //WM_SetCallback(hItem, Analysis_Btn_Callback);
    //WM_InvalidateWindow(hItem);
    
    //判断WBCHGB_TestInfo,消息头中的错误码，如果有错误，发送消息给当前界面，弹出错误框
    if(g_tUI_Info.tWBCHGB_TestInfo.tMsgHead.eErrorCode != ERROR_CODE_SUCCESS)
    {   
        //保存错误码，由于一次刷新会多次调用WM_PAINT, 而消息只需发送一次，所以这里改变eErrorCode的值
        g_ulErrorCode = g_tUI_Info.tWBCHGB_TestInfo.tMsgHead.eErrorCode;
        g_tUI_Info.tWBCHGB_TestInfo.tMsgHead.eErrorCode = ERROR_CODE_SUCCESS;
        //
        WM_SendMessageNoPara(pMsg->hWin, WM_ANALYSIS_ERROR_PORMPT);
    }
}


/*
*    UI send last record msg to backend 
*/
static ErrorCode_e UI_LastRecord_Msg(WM_MESSAGE* pMsg)
{
    extern __IO UI_Info_t	g_tUI_Info;
    uint8_t ucaSendBuffer[UI_TO_BACKEND_MSG_BUFFER_LEN] = {0};
    
    LastRecord_t *ptLastRecord = (LastRecord_t*)ucaSendBuffer;

    if(g_tUI_Info.tWBCHGB_TestInfo.ulCurDataSN > 0)
    {
        //消息头
        ptLastRecord->tMsgHead.usCmd       = CMD_ANALYSIS_LAST_RECORD;
        ptLastRecord->tMsgHead.eErrorCode  = ERROR_CODE_SUCCESS;
        ptLastRecord->tMsgHead.usMsgLen    = sizeof(LastRecord_t) - INNER_MSG_HEAD_LEN;
        //消息体
        //
        if(g_tUI_Info.tWBCHGB_TestInfo.ulCurDataSN == 0 || g_tUI_Info.tWBCHGB_TestInfo.ulCurDataSN == g_tUI_Info.tDataManage.ulFirstSN) //已是第一条
        {
            LOG_Info("It Already First Data, CurSN=%d, FirstSN=%d", g_tUI_Info.tWBCHGB_TestInfo.ulCurDataSN, g_tUI_Info.tDataManage.ulFirstSN);
            //失能上一记录按键
            WM_DisableWindow(WM_GetDialogItem(pMsg->hWin, ID_BUTTON_LAST_RECORD)); 
            return ERROR_CODE_FAILURE;
        }
        ptLastRecord->ulLastDataSN         = g_tUI_Info.tWBCHGB_TestInfo.ulCurDataSN - 1;
        ptLastRecord->eTestMode            = TEST_MODE_WBC_HGB;

        //发送消息给后端
        if(osOK != UI_Put_Msg((uint8_t*)ucaSendBuffer)) //osOk != ...
        {
            LOG_Error("Send Msg Fail");
            return ERROR_CODE_FAILURE;
        }
    }
    return ERROR_CODE_SUCCESS;
}


/*
*    UI send next record msg to backend
*/
static ErrorCode_e UI_NextRecord_Msg(WM_MESSAGE* pMsg)
{
    extern __IO UI_Info_t	g_tUI_Info;
    uint8_t ucaSendBuffer[UI_TO_BACKEND_MSG_BUFFER_LEN] = {0};
    
    NextRecord_t *ptNextRecord = (NextRecord_t*)ucaSendBuffer;
    //消息头
    ptNextRecord->tMsgHead.usCmd      = CMD_ANALYSIS_NEXT_RECORD;
    ptNextRecord->tMsgHead.eErrorCode = ERROR_CODE_SUCCESS;
    ptNextRecord->tMsgHead.usMsgLen   = sizeof(NextRecord_t) - INNER_MSG_HEAD_LEN;
    //消息体
    if(g_tUI_Info.tWBCHGB_TestInfo.ulCurDataSN + 1 >= g_tUI_Info.tDataManage.ulLastestSN)
    {
        //没有下一记录
        LOG_Info("It Already Lastest Data, CurSN=%d, FirstSN=%d", g_tUI_Info.tWBCHGB_TestInfo.ulCurDataSN, g_tUI_Info.tDataManage.ulLastestSN);
        //失能下一记录按键
        WM_DisableWindow(WM_GetDialogItem(pMsg->hWin, ID_BUTTON_NEXT_RECORD)); 
        
        return ERROR_CODE_FAILURE;
    }
    ptNextRecord->ulNextDataSN        = g_tUI_Info.tWBCHGB_TestInfo.ulCurDataSN + 1;
    ptNextRecord->eTestMode           = TEST_MODE_WBC_HGB;

    //发送消息给后端
    if(0 != UI_Put_Msg((uint8_t*)ucaSendBuffer)) //osOk != ...
    {
        LOG_Error("Send Msg Fail");
        return ERROR_CODE_FAILURE;
    }
    
    //
    return ERROR_CODE_SUCCESS;
}



/*
*    UI send print  msg to backend
*/
static ErrorCode_e UI_Print_Msg(WM_MESSAGE* pMsg)
{
    extern __IO UI_Info_t	g_tUI_Info;
    uint8_t ucaSendBuffer[UI_TO_BACKEND_MSG_BUFFER_LEN] = {0};
    
    Print_t *ptPrint = (Print_t*)ucaSendBuffer;
    
    if((g_tUI_Info.tDataManage.ulFirstSN == 0 && g_tUI_Info.tDataManage.ulLastestSN == 0) || g_tUI_Info.tDataManage.ulLastestSN == 0)//无记录
    {
        //失能上一记录按键
        WM_DisableWindow(WM_GetDialogItem(pMsg->hWin, ID_BUTTON_LAST_RECORD));
        //失能下一记录按键
        WM_DisableWindow(WM_GetDialogItem(pMsg->hWin, ID_BUTTON_NEXT_RECORD)); 
    }else{
        //消息头
        ptPrint->tMsgHead.usCmd       = CMD_ANALYSIS_PRINT;
        ptPrint->tMsgHead.eErrorCode  = ERROR_CODE_SUCCESS;
        ptPrint->tMsgHead.usMsgLen    = sizeof(Print_t) - INNER_MSG_HEAD_LEN;
        //消息体
        ptPrint->ulCurDataSN          = g_tUI_Info.tWBCHGB_TestInfo.ulCurDataSN;
        ptPrint->eTestMode            = TEST_MODE_WBC_HGB;
        
        //发送消息给后端
        if(0 != UI_Put_Msg(ucaSendBuffer)) //osOk != ...
        {
            LOG_Error("Send Msg Fail");
            return ERROR_CODE_FAILURE;
        }
    }
    return ERROR_CODE_SUCCESS;
}



/*********************************************************************
*
*       _cbDialog
*/
static void Analysis_cbDialog(WM_MESSAGE * pMsg) {
    
  extern osThreadId_t AlgoHandle;
  extern osSemaphoreId xSema_Count_Key;
    
  WM_HWIN hItem;
  int     NCode, i = 0;
  int     Id;
  // USER START (Optionally insert additional variables)
  // USER END

  switch (pMsg->MsgId) {
  case WM_INIT_DIALOG:
    //
    // Initialization of 'wbc hgb reslut_Listview'
    //
    Analysis_Msg_Init(pMsg);
    //Analysis_Msg_Updata(pMsg);
    // USER START (Optionally insert additional code for further widget initialization)
    //SampleMenu_Data_Updata(pMsg);
    // USER END
    break;
//  case WM_PAINT:
//  {
//      Analysis_Msg_Updata(pMsg);
//  }
  break;
  case WM_MENU_UPDATE:
  {
     Analysis_Msg_Updata(pMsg);
  }
  break;
  case WM_DELETE:
  {
    //当退出分析界面时，清除信号量，挂起算法任务
    osSemaphoreAcquire(xSema_Count_Key, 0);
    osThreadSuspend(AlgoHandle);
  }
  break;
  case WM_ANALYSIS_ERROR_PORMPT: //样本分析，错误提示窗口
  {
      //因为执行GUI_EndDialog，会调用一次当前背景窗口的callback，所以需要先切换到下一个背景窗口的callback
      //WM_SetCallback(WM_HBKWIN, ErrorPrompt_cbBkWin); 
      //WM_SetCallback(WM_HBKWIN, None_cbBkWin);
      GUI_EndDialog(pMsg->hWin, 0);
      //GUI_Exec();

      g_hActiveWin = ErrorPrompt_Window();
  }
  break;
  case WM_NOTIFY_PARENT:
    Id    = WM_GetId(pMsg->hWinSrc);
    NCode = pMsg->Data.v;
    switch(Id) {
   
    case ID_BUTTION_WBCHGB_RESULT: // Notifications sent by 'reslut_Listview'
      switch(NCode) {
      case WM_NOTIFICATION_CLICKED:
        // USER START (Optionally insert code for reacting on notification message)
        // USER END
        break;
      case WM_NOTIFICATION_RELEASED:
        // USER START (Optionally insert code for reacting on notification message)
        // USER END
        break;
      case WM_NOTIFICATION_SEL_CHANGED:
        // USER START (Optionally insert code for reacting on notification message)
        // USER END
        break;
      // USER START (Optionally insert additional code for further notification handling)
      // USER END
      }
      break;
    case ID_BUTTON_LAST_RECORD: // Notifications sent by 'lastRecord_btn'
      switch(NCode) {
      case WM_NOTIFICATION_CLICKED:
        // USER START (Optionally insert code for reacting on notification message)
        
		// USER END
        break;
      case WM_NOTIFICATION_RELEASED:
        // USER START (Optionally insert code for reacting on notification message)
        UI_LastRecord_Msg(pMsg);
        // USER END
        break;
      // USER START (Optionally insert additional code for further notification handling)
      // USER END
      }
      break;
    case ID_BUTTON_NEXT_RECORD: // Notifications sent by 'nextRecord_btn'
      switch(NCode) {
      case WM_NOTIFICATION_CLICKED:
        // USER START (Optionally insert code for reacting on notification message)
        // USER END
        break;
      case WM_NOTIFICATION_RELEASED:
        // USER START (Optionally insert code for reacting on notification message)
        UI_NextRecord_Msg(pMsg);
        // USER END
        break;
      // USER START (Optionally insert additional code for further notification handling)
      // USER END
      }
      break;
    case ID_BUTTON_NEXT_SAMPLE: // Notifications sent by 'nextTest_btn'
      switch(NCode) {
      case WM_NOTIFICATION_CLICKED:
        // USER START (Optionally insert code for reacting on notification message)

        // USER END
        break;
      case WM_NOTIFICATION_RELEASED:
        // USER START (Optionally insert code for reacting on notification message)
        GUI_EndDialog(pMsg->hWin, 0);
        g_hActiveWin = CreateNextSample_Window();
        // USER END
        break;
      // USER START (Optionally insert additional code for further notification handling)
      // USER END
      }
      break;
    case ID_BUTTON_PRINT: // Notifications sent by 'print_btn'
      switch(NCode) {
      case WM_NOTIFICATION_CLICKED:
        // USER START (Optionally insert code for reacting on notification message)
        
        // USER END
        break;
      case WM_NOTIFICATION_RELEASED:
        // USER START (Optionally insert code for reacting on notification message)
        UI_Print_Msg(pMsg);
        // USER END
        break;
      // USER START (Optionally insert additional code for further notification handling)
      // USER END
      }
      break;
    case ID_BUTTON_PATIENT_INFO: // Notifications sent by 'testerInfo_btn'
      switch(NCode) {
      case WM_NOTIFICATION_CLICKED:
        // USER START (Optionally insert code for reacting on notification message)

        // USER END
        break;
      case WM_NOTIFICATION_RELEASED:
        // USER START (Optionally insert code for reacting on notification message)
        GUI_EndDialog(pMsg->hWin, 0);
        g_hActiveWin = CreatePatient_Info_Window();
        // USER END
        break;
      // USER START (Optionally insert additional code for further notification handling)
      // USER END
      }
      break;


    // USER START (Optionally insert additional code for further Ids)
    // USER END
    }
    break;
  // USER START (Optionally insert additional message handling)
  // USER END
  default:
    WM_DefaultProc(pMsg);
    break;
  }
}

/*********************************************************************
*
*       Public code
*
**********************************************************************
*/
/*********************************************************************
*
*       Analysis_Menu
*/
WM_HWIN Analysis_Menu(void);
WM_HWIN Analysis_Menu(void) {
    
  extern osThreadId_t AlgoHandle;
  extern osSemaphoreId xSema_Count_Key;
  WM_HWIN hWin;
    
  WM_SetCallback(WM_HBKWIN, Public_cbBkWin);
  Pulic_Show_Widget();

  //进入样本分析界面，使能算法任务，清除信号量
  osSemaphoreAcquire(xSema_Count_Key, 0);
  osThreadResume(AlgoHandle);
  hWin = GUI_CreateDialogBox(Analysis_aDialogCreate, GUI_COUNTOF(Analysis_aDialogCreate), Analysis_cbDialog, WM_HBKWIN, 0, 0);
  return hWin;
}

// USER START (Optionally insert additional public code)
// USER END

/*************************** End of file ****************************/
