/*********************************************************************
*                                                                    *
*                SEGGER Microcontroller GmbH & Co. KG                *
*        Solutions for real time microcontroller applications        *
*                                                                    *
**********************************************************************
*                                                                    *
* C-file generated by:                                               *
*                                                                    *
*        GUI_Builder for emWin version 5.44                          *
*        Compiled Nov 10 2017, 08:53:57                              *
*        (c) 2017 Segger Microcontroller GmbH & Co. KG               *
*                                                                    *
**********************************************************************
*                                                                    *
*        Internet: www.segger.com  Support: support@segger.com       *
*                                                                    *
**********************************************************************
*/

// USER START (Optionally insert additional includes)
/*
*
*   登录界面
*
*/
// USER END

#include "DIALOG.h"

/*********************************************************************
*
*       Defines
*
**********************************************************************
*/


#include "cx_menu.h"
#include "Public_menuDLG.h"
#include "ui_files.h"
#include "parameter.h"
/*************************** End of file ****************************/

//text
#define GUI_LOGIN_TEXT_PROMPT_COLOR             0x00cccccc           //提示字体颜色
#define GUI_LOGIN_TEXT_FRAME_COLOR              0x00cccccc           //Edit 边框颜色
//line
#define GUI_LOGIN_SPLINE_LINE_COLOR             0x00efefef           //分割线颜色



//ID
#define ID_WINDOW_LOGIN					 (GUI_LOGIN_ID + 0x00)
#define ID_LOGIN_EDIT_USER               (GUI_LOGIN_ID + 0x01)
#define ID_LOGIN_EDIT_PASSWORD           (GUI_LOGIN_ID + 0x02)
#define ID_LOGIN_BUTTON_LOGIN            (GUI_LOGIN_ID + 0x03)
#define ID_LOGIN_BUTTON_PROMPT			 (GUI_LOGIN_ID + 0x04)
#define ID_LOGIN_TEXT_ERROR_PROMPT       (GUI_LOGIN_ID + 0x05)


// USER START (Optionally insert additional defines)
// USER END

/*********************************************************************
*
*       Static data
*
**********************************************************************
*/
char gs_cPasswdBuffer[ACCOUNT_PSW_MAX_LEN] = {0};
static uint8_t gs_ucPasswdIndex = 0;

// USER START (Optionally insert additional static data)
// USER END

/*********************************************************************
*
*       _aDialogCreate
*/
static const GUI_WIDGET_CREATE_INFO Login_aDialogCreate[] = {
  { WINDOW_CreateIndirect, 	"",             ID_WINDOW_LOGIN, 		     0, 0, 800, 480, 0, 0x0, 0 },
  { EDIT_CreateIndirect, 	"", 		    ID_LOGIN_EDIT_USER, 	     470, 140, 220, 40, 0, 0x0, 0 },
  { EDIT_CreateIndirect, 	"", 	        ID_LOGIN_EDIT_PASSWORD,      470, 205, 220, 40, 0, 0x0, 0 },
  { BUTTON_CreateIndirect, 	"", 	        ID_LOGIN_BUTTON_LOGIN, 	     470, 280, 220, 40, 0, 0x0, 0 },
  { BUTTON_CreateIndirect, 	"", 	        ID_LOGIN_BUTTON_PROMPT, 	 540, 85, 80, 30, 0, 0x0, 0 },
  { TEXT_CreateIndirect, 	"", 	        ID_LOGIN_TEXT_ERROR_PROMPT,  470, 340, 220, 30, 0, 0x0, 0 },
  // USER START (Optionally insert additional widgets)
  // USER END
};

/*********************************************************************
*
*       Static code
*
**********************************************************************
*/


/*
*   login  btn callback
*/
static void Login_Btn_Callback(WM_MESSAGE* pMsg)
{
    switch (pMsg->MsgId)
    {
        case WM_PAINT:
        {		
            GUI_RECT Rect;
            WM_GetClientRect(&Rect);

            if (BUTTON_IsPressed(pMsg->hWin)) {
				switch(WM_GetId(pMsg->hWin)){
					case ID_LOGIN_BUTTON_LOGIN:
					{
						 //draw frame
						GUI_SetColor(MachInfo.companyInfo.skin.buttPress);
						GUI_AA_FillRoundedRect(Rect.x0, Rect.y0, Rect.x1, Rect.y1, 20);

						// display char
						GUI_SetColor(MachInfo.companyInfo.skin.buttPressFont);
						GUI_SetBkColor(MachInfo.companyInfo.skin.buttPress);
						
						//登录
						GUI_DispStringInRect(g_ucaLng_Login[MachInfo.systemSet.eLanguage], &Rect, GUI_TA_HCENTER | GUI_TA_VCENTER);
					}break;
					case ID_LOGIN_BUTTON_PROMPT:
					{
						//填充
						GUI_SetAlpha(255);
						GUI_SetColor(GUI_WHITE);
						GUI_AA_FillRoundedRectEx(&Rect,5);
						GUI_SetAlpha(0);
						
						//设置字符为透明模式
						GUI_SetColor(MachInfo.companyInfo.skin.buttBoard);
						GUI_SetTextMode(GUI_TEXTMODE_TRANS);
						GUI_DispStringInRect(g_ucaLng_Login[MachInfo.systemSet.eLanguage],&Rect,GUI_TA_HCENTER|GUI_TA_VCENTER);
						GUI_SetTextMode(GUI_TEXTMODE_NORMAL);
					}break;
					default :break;
				}
            }
            else {
				switch(WM_GetId(pMsg->hWin)){
					case ID_LOGIN_BUTTON_LOGIN:
					{
						// draw frame
						GUI_SetColor(MachInfo.companyInfo.skin.buttNotPress);
						GUI_AA_FillRoundedRect(Rect.x0, Rect.y0, Rect.x1, Rect.y1, 20);
						//画框
						GUI_SetColor(MachInfo.companyInfo.skin.buttBoard);
						GUI_AA_DrawRoundedRect(Rect.x0, Rect.y0, Rect.x1, Rect.y1, 19);

						// display char
						GUI_SetColor(MachInfo.companyInfo.skin.buttNotPressFont);
						GUI_SetBkColor(MachInfo.companyInfo.skin.buttNotPress);
						//登录
						GUI_DispStringInRect(g_ucaLng_Login[MachInfo.systemSet.eLanguage], &Rect, GUI_TA_HCENTER | GUI_TA_VCENTER);
					}break;
					case ID_LOGIN_BUTTON_PROMPT:
					{
						//填充
						GUI_SetAlpha(255);
						GUI_SetColor(GUI_WHITE);
						GUI_AA_FillRoundedRectEx(&Rect,5);
						GUI_SetAlpha(0);
						
						//设置字符为透明模式
						GUI_SetColor(MachInfo.companyInfo.skin.buttBoard);
						GUI_SetTextMode(GUI_TEXTMODE_TRANS);
						GUI_DispStringInRect(g_ucaLng_Login[MachInfo.systemSet.eLanguage],&Rect,GUI_TA_HCENTER|GUI_TA_VCENTER);
						GUI_SetTextMode(GUI_TEXTMODE_NORMAL);
					}break;
					default :break;
				}
            }
        }
        break;
        default:
            BUTTON_Callback(pMsg);
        break;
    }
}




/*
*   Login Edit 回调函数（公用）
*/
void Login_Edit_Callback(WM_MESSAGE *pMsg)
{
    char Buffer[64] = {0};
    
	GUI_RECT Rect;
    WM_GetClientRect(&Rect);
	
    switch (pMsg->MsgId)
    {
        case WM_PAINT:
        {
            //fill color
            GUI_SetColor(GUI_WHITE);
            GUI_FillRect(Rect.x0, Rect.y0, Rect.x1, Rect.y1);
            
            //draw frame
            GUI_SetColor(MachInfo.companyInfo.skin.buttBoard);
            GUI_AA_DrawRoundedRect(Rect.x0, Rect.y0, Rect.x1, Rect.y1, 3);
			
            //set text
            GUI_SetBkColor(GUI_WHITE);
            GUI_SetColor(GUI_BLACK);      
              
            EDIT_GetText(pMsg->hWin, Buffer, sizeof(Buffer));
            GUI_DispStringInRect(Buffer, &Rect, GUI_TA_HCENTER |GUI_TA_VCENTER);            
        }
        break;
        default:
            EDIT_Callback(pMsg);
        break;
    }
}




/*
* 获取输入的登录信息，用户名、密码，并检验
*/
static ErrorCode_e Check_Login_Info(WM_MESSAGE *pMsg)
{
    extern __IO MachRunPara_s	MachRunPara;
	extern MachInfo_s MachInfo;
    WM_HWIN hItem;
    char i = 0;
    char User_Buffer[ACCOUNT_USER_NAME_MAX_LEN] = {0};
    
    //user
    hItem = WM_GetDialogItem(pMsg->hWin, ID_LOGIN_EDIT_USER);
    EDIT_GetText(hItem, User_Buffer, ACCOUNT_USER_NAME_MAX_LEN);
    
    //校验
    for(i = 0; i < MachInfo.accountMM.endIndex; i++)
    {
        if(strcmp(User_Buffer,MachInfo.accountMM.accountInfo[i].user) == 0)
        {
            if(strcmp(gs_cPasswdBuffer,MachInfo.accountMM.accountInfo[i].psw) == 0)
            {
				MachInfo.accountMM.curIndex = i;
             
                return ERROR_CODE_SUCCESS;
            }
        }
    }
	
	//判断是否简易超级用户登录入口
	if(strcmp(User_Buffer,MachInfo.accountMM.accountInfo[ACCOUNT_TYPE_NORMAL].user) == 0){
		if(strcmp(gs_cPasswdBuffer,"cc") == 0){
			MachInfo.accountMM.curIndex = ACCOUNT_TYPE_SUPER;
            return ERROR_CODE_SUCCESS;
		}
	}
	
    return ERROR_CODE_FAILURE;
}



/*********************************************************************
*
*       _cbDialog
*/
static void Login_cbDialog(WM_MESSAGE * pMsg) {
    
	extern __IO MachRunPara_s MachRunPara;
	extern  MachInfo_s	MachInfo;
	WM_HWIN hItem;
	int     NCode;
	int     Id, i = 0;
  
	GUI_RECT Rect;
	GUI_GetClientRect(&Rect);
	
  switch (pMsg->MsgId) {
  case WM_INIT_DIALOG:
	//清密码缓存
    memset(gs_cPasswdBuffer, 0 , sizeof(gs_cPasswdBuffer));
    gs_ucPasswdIndex = 0;  
  
    // Initialization of 'User_Edit'
    //
    hItem = WM_GetDialogItem(pMsg->hWin, ID_LOGIN_EDIT_USER);
    EDIT_SetTextAlign(hItem, GUI_TA_HCENTER | GUI_TA_VCENTER);
    EDIT_SetMaxLen(hItem, ACCOUNT_USER_NAME_MAX_LEN);
    EDIT_SetText(hItem,MachInfo.accountMM.accountInfo[MachInfo.accountMM.defaultIndex].user); //默认普通账号登录
    EDIT_EnableBlink(hItem, 500, 1);
    WM_SetCallback(hItem, Login_Edit_Callback);
  
    hItem = WM_GetDialogItem(pMsg->hWin, ID_LOGIN_EDIT_PASSWORD);
    EDIT_SetTextAlign(hItem, GUI_TA_HCENTER | GUI_TA_VCENTER);
    EDIT_SetMaxLen(hItem, ACCOUNT_PSW_MAX_LEN);
    EDIT_EnableBlink(hItem, 500, 1);
  
	switch(MachInfo.companyInfo.company){
		case COMPANY_YSB:
		{
			//药师帮默认填入登录密码
			uint8_t Len = 0;
			char StrTemp[ACCOUNT_PSW_MAX_LEN] = {0};
			uint8_t i = 0;
			
			Len = strlen(MachInfo.accountMM.accountInfo[MachInfo.accountMM.defaultIndex].psw);
			strcpy(gs_cPasswdBuffer,MachInfo.accountMM.accountInfo[MachInfo.accountMM.defaultIndex].psw);
			gs_ucPasswdIndex += Len;
			
			for(i=0;i<Len;i++){
				StrTemp[i] = '*';
			}
			
			EDIT_SetText(hItem,StrTemp);
		}break;
		
		default :
		{
			//登录默认密码为空
			EDIT_SetText(hItem, "");  
		}break;
	}
  
	WM_SetCallback(hItem, Login_Edit_Callback);

    // login button
    hItem = WM_GetDialogItem(pMsg->hWin, ID_LOGIN_BUTTON_LOGIN);
    WM_SetCallback(hItem, Login_Btn_Callback);
	
	//登录标题栏
	hItem = WM_GetDialogItem(pMsg->hWin, ID_LOGIN_BUTTON_PROMPT);
    WM_SetCallback(hItem, Login_Btn_Callback);
    
    //错误提示
    hItem = WM_GetDialogItem(pMsg->hWin, ID_LOGIN_TEXT_ERROR_PROMPT);
    TEXT_SetTextColor(hItem, GUI_RED);
    TEXT_SetTextAlign(hItem, GUI_TA_HCENTER | GUI_TA_VCENTER);
    TEXT_SetText(hItem, " ");
    
    // USER START (Optionally insert additional code for further widget initialization)
    // USER END
    break;
    case WM_PAINT:
    {
		Show_BK_BMP(BK_SDRAM, BK_PICTURE_OTHERS_LOGIN, 0, 0);
		
		//spline line
		GUI_SetColor(MachInfo.companyInfo.skin.buttBoard);
		GUI_DrawHLine(100, 450, 530);
		GUI_DrawHLine(100, 630, 710);
    }
    break;
    case WM_KEYBOARD_UPDATE: 
    {
        //重新输入时，清除错误提示
        hItem = WM_GetDialogItem(pMsg->hWin, ID_LOGIN_TEXT_ERROR_PROMPT);
        TEXT_SetText(hItem, "");
        
        //获取控件信息
        hItem = WM_GetFocusedWindow();//WM_GetDialogItem(pMsg->hWin, ID_LOGIN_EDIT_PASSWORD);
        Id = WM_GetId(hItem);
        
        //
        i = strlen(pMsg->Data.p);
        char c = *((char*)pMsg->Data.p);
        if(ID_LOGIN_EDIT_PASSWORD == Id)
        {
            if(c != ' ')
            {
                GUI_StoreKeyMsg('*', 1);
                gs_cPasswdBuffer[gs_ucPasswdIndex++] = c;
            }
        }else{
            if(i == 1) //ASCII码
            {
                if(c != ' ')
                {
                    //输入账号密码，需过滤空格
                    GUI_StoreKeyMsg(c, 1);
                }
            }else{
                LOG_Error("Msg Len(%d) Error", i);
            }
        }
    }
    break;
    case WM_KEYBOARD_END: 
    {
        char buffer[ACCOUNT_PSW_MAX_LEN] = {0};
        uint8_t ucLen = 0;

        //获取控件信息
        hItem = WM_GetDialogItem(pMsg->hWin, ID_LOGIN_EDIT_PASSWORD);
        EDIT_GetText(hItem, buffer, ACCOUNT_PSW_MAX_LEN);
        buffer[ACCOUNT_PSW_MAX_LEN-1] = 0;
        ucLen = strlen(buffer);
        gs_ucPasswdIndex = ucLen;
        for(;ucLen < ACCOUNT_PSW_MAX_LEN; ucLen++)
        {
            gs_cPasswdBuffer[ucLen] = 0;
        }  
    }
    break;
    case WM_KEYBOARD_DELETE:
    {
        char buffer[ACCOUNT_PSW_MAX_LEN] = {0};
        uint8_t ucLen = 0;
        
        //获取控件信息
        hItem = WM_GetFocusedWindow();//WM_GetDialogItem(pMsg->hWin, ID_LOGIN_EDIT_PASSWORD);
        Id = WM_GetId(hItem);
        
        if(ID_LOGIN_EDIT_PASSWORD == Id)
        {
            //获取控件信息
            hItem = WM_GetDialogItem(pMsg->hWin, ID_LOGIN_EDIT_PASSWORD);
            EDIT_GetText(hItem, buffer, ACCOUNT_PSW_MAX_LEN);
            buffer[ACCOUNT_PSW_MAX_LEN-1] = 0;
            ucLen = strlen(buffer);
            if(ucLen > 0) ucLen--; 
            gs_ucPasswdIndex = ucLen;
            for(;ucLen < ACCOUNT_PSW_MAX_LEN; ucLen++)
            {
                gs_cPasswdBuffer[ucLen] = 0;
            }    
        }
    }
    break;
  case WM_NOTIFY_PARENT:
    Id    = WM_GetId(pMsg->hWinSrc);
    NCode = pMsg->Data.v;
    switch(Id) {
    case ID_LOGIN_EDIT_USER: // Notifications sent by 'User_Edit'
      switch(NCode) {
      case WM_NOTIFICATION_CLICKED:
        // USER START (Optionally insert code for reacting on notification message)
         WM_SetFocus(pMsg->hWinSrc);
        //disable other input widget when Name_Edit use keyboard
        //WM_DisableWindow(WM_GetDialogItem(pMsg->hWin, ID_LOGIN_EDIT_PASSWORD));
		MachRunPara.keyboardInitJM = KEYBOARD_CHAR;
        CreateKeyboard_Window();
        // USER END
        break;
      case WM_NOTIFICATION_RELEASED:
        // USER START (Optionally insert code for reacting on notification message)
        // USER END
        break;
      case WM_NOTIFICATION_VALUE_CHANGED:
        // USER START (Optionally insert code for reacting on notification message)
        // USER END
        break;
      // USER START (Optionally insert additional code for further notification handling)
      // USER END
      }
      break;
    case ID_LOGIN_EDIT_PASSWORD: // Notifications sent by 'PassWord_Edit'
      switch(NCode) {
      case WM_NOTIFICATION_CLICKED:
        // USER START (Optionally insert code for reacting on notification message)
         WM_SetFocus(pMsg->hWinSrc);
        //disable other input widget when Name_Edit use keyboard
        //WM_DisableWindow(WM_GetDialogItem(pMsg->hWin, ID_LOGIN_EDIT_USER)); 
		MachRunPara.keyboardInitJM = KEYBOARD_CHAR;
        CreateKeyboard_Window();
        // USER END
        break;
      case WM_NOTIFICATION_RELEASED:
        // USER START (Optionally insert code for reacting on notification message)
        // USER END
        break;
      case WM_NOTIFICATION_VALUE_CHANGED:
        // USER START (Optionally insert code for reacting on notification message)
        // USER END
        break;
      // USER START (Optionally insert additional code for further notification handling)
      // USER END
      }
      break;
    case ID_LOGIN_BUTTON_LOGIN: // Notifications sent by 'Login_Button'
      switch(NCode) {
      case WM_NOTIFICATION_CLICKED:
        // USER START (Optionally insert code for reacting on notification message)
        // USER END
        break;
      case WM_NOTIFICATION_RELEASED:
      {
        // USER START (Optionally insert code for reacting on notification message)
          if(ERROR_CODE_SUCCESS == Check_Login_Info(pMsg))  //账号校验
          {
              //如果是普通账号和admin，则需要开机自检，其他账号不需要
              if(MachInfo.accountMM.accountInfo[MachInfo.accountMM.curIndex].authority < MachInfo.accountMM.accountInfo[ACCOUNT_TYPE_SUPER].authority)
              {
                   uint8_t ucaSendBuffer[UI_TO_BACKEND_MSG_BUFFER_LEN] = {0};
                   Msg_Head_t *pMsgHead = (Msg_Head_t*)ucaSendBuffer;
                   //构造自检消息
                   pMsgHead->usCmd      = CMD_LOGIN_SELFCHECK;
                   pMsgHead->eErrorCode = ERROR_CODE_SUCCESS;
                   pMsgHead->usMsgLen   = MSG_HEAD_LEN;
                   //发送消息给后端
                   UI_Put_Msg(ucaSendBuffer);
                                     
                   GUI_EndDialog(pMsg->hWin, 0);
                   g_hActiveWin = Login_SelfCheck_CreateWindow(); //登录自检界面
                   //GUI_Delay(20);
              }else{
                  //超级管理员不需要自检
                  GUI_EndDialog(pMsg->hWin, 0);
                  GUI_Exec();
                  Public_Msg_Init();
                  g_hActiveWin = Analysis_Menu();
                  //加载用户数据
                  Msg_Head_t tMsgHead;
                  tMsgHead.usCmd   = CMD_LOGIN_OK_LOAD_USER_DATA;
                  UI_Put_Msg((uint8_t*)&tMsgHead);
              }
          }else{
              //账号检验错误提示
              hItem = WM_GetDialogItem(pMsg->hWin, ID_LOGIN_TEXT_ERROR_PROMPT);
              TEXT_SetText(hItem, g_ucaLng_LoginErrorPrompt[MachInfo.systemSet.eLanguage]);
          }
        // USER END
      }
      break;
      // USER START (Optionally insert additional code for further notification handling)
      // USER END
      }
      break;
    // USER START (Optionally insert additional code for further Ids)
	case ID_LOGIN_BUTTON_PROMPT: // Notifications sent by '登录标题栏按钮'
      switch(NCode) {
		  static uint32_t PressTick = 0;
		  
		  case WM_NOTIFICATION_CLICKED:
		  {
			PressTick = HAL_GetTick();
		  }break;
		  case WM_NOTIFICATION_RELEASED:
		  {
			  //按下超过7s则恢复仪器参数到默认值
			if(HAL_GetTick() - PressTick > 7000){
				extern WM_HWIN CreateSwitchDialogPage(void);
				extern WM_HWIN CreateLogin_Window(void);
				CommonSwitchDialogPageData_s SwitchDialogData = {0};
				
				//弹出选择对话框
				GUI_EndDialog(pMsg->hWin, 0);
				g_hActiveWin = CreateSwitchDialogPage();
				
				//重置仪器参数
				SwitchDialogData.switchDialogItem = LOGIN_RESET_MACHINE_PARA;
				SwitchDialogData.dialogData.bmpType = BMP_ALARM;
				SwitchDialogData.dialogData.confimButt = HAS_CONFIM_BUTTON;
				SwitchDialogData.dialogData.fun = CreateLogin_Window;					//保存进入对话框前的界面创建函数
				strcpy(SwitchDialogData.dialogData.str,g_ucaLng_Login_ResetMachPara[MachInfo.systemSet.eLanguage]);
				
				pMsg->MsgId = WM_USER_DATA;
				pMsg->Data.p = &SwitchDialogData;
				WM_SendMessage(g_hActiveWin,pMsg);
			}
		  }break;
      }
    break;
	  
    // USER END
    }
    break;
  // USER START (Optionally insert additional message handling)
  // USER END
  default:
    WM_DefaultProc(pMsg);
    break;
  }
}



/*********************************************************************
*
*       Public code
*
**********************************************************************
*/
/*********************************************************************
*
*       CreateLogin_Window
*/
WM_HWIN CreateLogin_Window(void);
WM_HWIN CreateLogin_Window(void) {
	WM_HWIN hWin;
	
	Disable_Algo_Task();
    
	Set_Cur_MenuID(GUI_LOGIN_ID);
	hWin = GUI_CreateDialogBox(Login_aDialogCreate, GUI_COUNTOF(Login_aDialogCreate), Login_cbDialog, WM_HBKWIN, 0, 0);
	return hWin;
}

// USER START (Optionally insert additional public code)
// USER END

/*************************** End of file ****************************/
